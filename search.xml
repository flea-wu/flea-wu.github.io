<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Docker 相关命令小计</title>
      <link href="/docker/2021-02-18-docker-xiang-guan-ming-ling-xiao-ji/"/>
      <url>/docker/2021-02-18-docker-xiang-guan-ming-ling-xiao-ji/</url>
      
        <content type="html"><![CDATA[<h1><span id="docker-相关命令小计">Docker 相关命令小计</span></h1><p>docker network ls</p><p>查看创建的网络组</p><p>docker volume ls</p><p>查看创建的数据卷</p><p>docker volume rm xxx</p><p>删除数据卷</p><p>docker rm -v webapp</p><p>docker rm 删除容器的命令中，我们可以通过增加 -v 选项来删除容器关联的数据卷</p><p>如果我们没有随容器删除这些数据卷，Docker 在创建新的容器时也不会启用它们，即使它们与新创建容器所定义的数据卷有完全一致的特征。也就是说，此时它们已经变成了孤魂野鬼，纯粹的占用着硬盘空间而又不受管理。</p><p>docker volume prune</p><p>删除那些没有被容器引用的数据卷。</p><p>docker commit</p><p>将容器打成镜像</p><p>docker save / docker export</p><p>镜像的导出</p><p>docker load / docker import</p><p>镜像的导入</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sublime 写Java</title>
      <link href="/sublime/2021-02-17-sublime-xie-java/"/>
      <url>/sublime/2021-02-17-sublime-xie-java/</url>
      
        <content type="html"><![CDATA[<h1><span id="sublime-写-java">Sublime 写 Java</span></h1><h2><span id="1安装jdk">1.安装JDK</span></h2><p>官网下载，下载好后直接安装就可以了。</p><h2><span id="2新建java编译系统">2.新建java编译系统</span></h2><p>sublime工具中选择新建编译系统，配置文件内容如下</p><pre class=" language-language-json"><code class="language-language-json">{    "shell_cmd": "javac -encoding utf-8 $file_name && java $file_base_name",    "file_regex": "^ *\\[javac\\] (.+):([0-9]+):() (.*)$",    "selector": "source.java",        "encoding": "utf-8"}</code></pre><p>保存为 myJava.sublime-build</p><h2><span id="3测试">3.测试</span></h2><p>编写一个java文件，选择编译系统myJava，command+b编译运行</p><pre class=" language-language-java"><code class="language-language-java">public class hello {     public static void main(String args[]){    System.out.println("Hello Java 测试中文");    }}</code></pre><blockquote><p><a href="https://docle.github.io/2017/11/11/Compile-and-run-the-Java-program-in-Sublime-Text-3/" target="_blank" rel="noopener">https://docle.github.io/2017/11/11/Compile-and-run-the-Java-program-in-Sublime-Text-3/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Sublime </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sublime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 锁总结</title>
      <link href="/suo/2020-12-20-java-suo-zong-jie/"/>
      <url>/suo/2020-12-20-java-suo-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1><span id="java-锁总结">Java 锁总结</span></h1><h4><span id="1什么是悲观锁">1.什么是悲观锁：</span></h4><p>在多线程操作共享资源时，一次只能一个线程访问，从源头解决线程并发带来的错误影响</p><p>例子：A 写的时候，B不能读和写</p><p>实现方式：</p><p>synchronize 关键字或 ReentrantLock reentrantLock = new ReentrantLock(false);</p><h4><span id="2什么是乐观锁">2.什么是乐观锁：</span></h4><p>在多线程操作共享资源时，可以有多个线程访问，操作共享资源时再进行判断，再进行错误兼容</p><p>例子：A 写的时候，B能读；B 写的时候，发现 A 已经写了，或者 A 写的时候，发现 B 已经写了，报错或者其他异常逻辑</p><p>实现方式：</p><p>一般用 CAS 和 版本控制来实现</p><ul><li><p>什么是 CAS</p><p>全称 Compare and swap，字面意思:”比较并交换“</p><p>例子：</p><pre><code>我们假设内存中的共享变量原数据 A：a = 1，旧的预期值 V：a = 1，需要修改的新值 a = 2。由于 A 操作是可以被其他线程所影响的，若 A 操作被其他线程锁影响，将 a 的值改成非 1 ，则 Compare 失败，无法更新比较 A 与 V 是否相等。（比较）如果比较相等，将 B 写入 V。（交换）返回操作是否成功。</code></pre></li><li><p>CAS 有什么优缺点</p></li></ul><ul><li>用户态，系统态</li></ul><h4><span id="3什么是自旋锁">3.什么是自旋锁</span></h4><h4><span id="4什么是自适应自旋锁">4.什么是自适应自旋锁</span></h4><h4><span id="5无锁">5.无锁</span></h4><h4><span id></span></h4><h4><span id="6偏向锁">6.偏向锁</span></h4><h4><span id="7轻量级锁">7.轻量级锁</span></h4><h4><span id="8重量级锁">8.重量级锁</span></h4><h4><span id="9公平锁">9.公平锁</span></h4><h4><span id="10非公平锁">10.非公平锁</span></h4><h4><span id="11可重入锁">11.可重入锁</span></h4><h4><span id="12非可重入锁">12.非可重入锁</span></h4><h4><span id="13独享锁">13.独享锁</span></h4><h4><span id="14共享锁">14.共享锁</span></h4><h4><span id="15分段锁">15.分段锁</span></h4>]]></content>
      
      
      <categories>
          
          <category> 锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot 整合 knife4j</title>
      <link href="/springboot/knife4j/2020-12-12-springboot-zheng-he-knife4j/"/>
      <url>/springboot/knife4j/2020-12-12-springboot-zheng-he-knife4j/</url>
      
        <content type="html"><![CDATA[<h1><span id="springboot-整合-knife4j">Springboot 整合 knife4j</span></h1>]]></content>
      
      
      <categories>
          
          <category> Springboot </category>
          
          <category> knife4j </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 接口文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用阿里云做代理服务器</title>
      <link href="/zhua-bao/dai-li/2020-12-03-shi-yong-a-li-yun-zuo-dai-li-fu-wu-qi/"/>
      <url>/zhua-bao/dai-li/2020-12-03-shi-yong-a-li-yun-zuo-dai-li-fu-wu-qi/</url>
      
        <content type="html"><![CDATA[<h1><span id="使用阿里云做代理服务器">使用阿里云做代理服务器</span></h1><blockquote><p>有情怀，有干货，微信搜索【<strong>槑克码宁</strong>】关注这个不一样的程序员。</p></blockquote><h2><span id="前言">前言</span></h2><p>众所周知想要抓包，就得挂代理 ip ，获取代理 ip 的途径有很多。如第三方的服务商：快代理、芝麻、精灵等。网上能找的代理 ip 都有一个缺点：<strong>都有时长限制</strong>；我只想偶尔挂个代理测试抓取某个接口，该如何做？</p><h3><span id="使用阿里云服务器做代理服务器">使用阿里云服务器做代理服务器</span></h3><ol><li><p>买一台阿里云服务器</p><blockquote><p>xxx</p></blockquote></li><li><p>安装（代理软件：TinyProxy 和 Squid 都是比较优秀的代理软件）</p><ol><li><p>安装 TinyProxy</p><pre><code>yum install tinyproxy</code></pre></li><li><p>配置 TinyProxy</p><pre class=" language-language-sh"><code class="language-language-sh">1. 打开配置文件vim /etc/tinyproxy/tinyproxy.conf2. 修改 Port 端口，默认为 8888Port 88883. 注释掉 Allow，表示允许所有人访问代理#Allow 127.0.0.14. 隐藏掉Via请求头部，去掉下面的注释DisableViaHeader Yes</code></pre></li><li><p>启动 TinyProxy</p><pre class=" language-language-sh"><code class="language-language-sh">systemctl start tinyproxy.service </code></pre><p>更多配置</p><pre><code>1.启动service tinyproxy startservice tinyproxy stopservice tinyproxy restart2.启动systemctl tinyproxy startsystemctl tinyproxy.start startsystemctl tinyproxy.service start3.启动/bin/systemctl start tinyproxy.service1、2、3 都尝试下；不同环境启动的不一样</code></pre></li><li><p>在阿里云安全组中开放 8888 端口</p></li><li><p>测试是否成功</p><p>测试教程参见：<a href="https://www.wzzzzzz.com/zhua-bao/dai-li/2020-12-01-postman-pei-zhi-dai-li/">Postman 配置代理</a></p></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 抓包 </category>
          
          <category> 代理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Postman 配置代理</title>
      <link href="/zhua-bao/dai-li/2020-12-01-postman-pei-zhi-dai-li/"/>
      <url>/zhua-bao/dai-li/2020-12-01-postman-pei-zhi-dai-li/</url>
      
        <content type="html"><![CDATA[<h1><span id="postman-配置代理">Postman 配置代理</span></h1><p>1.使用快捷键 command + d 打开设置页面</p><p><img src="https://img.nbjike.com/jietu/20201201224333.png" alt></p><p>2.选择 proxy 进行如下图设置</p><p><img src="https://img.nbjike.com/jietu/20201201224512.png" alt></p><p>3.检验是否安装成功，访问 <a href="http://ipip.net" target="_blank" rel="noopener">ipip.net</a> 查看自己的 ip</p><p><img src="https://img.nbjike.com/jietu/20201201224604.png" alt></p><p><img src="https://img.nbjike.com/jietu/20201212151127.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 抓包 </category>
          
          <category> 代理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Idea 开发配置代理</title>
      <link href="/zhua-bao/2020-12-01-idea-kai-fa-pei-zhi-dai-li/"/>
      <url>/zhua-bao/2020-12-01-idea-kai-fa-pei-zhi-dai-li/</url>
      
        <content type="html"><![CDATA[<h1><span id="idea-开发配置代理">Idea 开发配置代理</span></h1><h3><span id="起因">起因</span></h3><p>因为本猿在开发代码中，遇到一个问题：在抓取第三方接口时，本地测试 OK 到生产环境中却不行，代码都是一份，但线上环境却不能正常使用，怀疑是线上是服务器 ip ，线上服务器 ip 会被识别，故想将本地环境模拟成线上环境发请求。</p><h3><span id="配置">配置</span></h3><p>1.打开 idea 设置，快捷键（command + ,）</p><p><img src="https://img.nbjike.com/jietu/20201201222034.png" alt></p><p>2.在输入框中输入 <strong>proxy</strong></p><p><img src="https://img.nbjike.com/jietu/20201201222622.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 抓包 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis 初始化流程</title>
      <link href="/yuan-ma/mybatis/2020-12-01-mybatis-chu-shi-hua-liu-cheng/"/>
      <url>/yuan-ma/mybatis/2020-12-01-mybatis-chu-shi-hua-liu-cheng/</url>
      
        <content type="html"><![CDATA[<h1><span id="mybatis-初始化流程">Mybatis 初始化流程</span></h1><p>加载数据源</p><p>接收一个 DataSource 实例</p><p>创建 SqlSessionFactoryBean 实例对象</p><p>SqlSessionFactory 是一个接口，默认有两个实例：</p><pre class=" language-language-java"><code class="language-language-java">public interface SqlSessionFactory {  SqlSession openSession();  SqlSession openSession(boolean autoCommit);  SqlSession openSession(Connection connection);  SqlSession openSession(TransactionIsolationLevel level);  SqlSession openSession(ExecutorType execType);  SqlSession openSession(ExecutorType execType, boolean autoCommit);  SqlSession openSession(ExecutorType execType, TransactionIsolationLevel level);  SqlSession openSession(ExecutorType execType, Connection connection);  Configuration getConfiguration();}</code></pre><p>默认的两个实例：</p><p><img src="https://img.nbjike.com/jietu/20201130204448.png" alt="默认的两个实例"></p><p>SqlSessionFactory 的作用是<strong>创建会话(SqlSession)</strong>，相当于 JDBC 的 Connection 连接；</p><pre class=" language-language-java"><code class="language-language-java">SqlSession sqlSession = null;try{sqlSesssion = sqlSessionFactory.openSesson();// And code you need；可以自定义业务代码sqlSession.commit();} catch(Exception e) {e.printStackTrace();} finally {if(sqlSession != null){sqlSession.close();}}</code></pre><p>实例：</p><pre class=" language-language-java"><code class="language-language-java">加载配置文件：String resource = "mybatis-config.xml";InputStream inputStream = Resource.getResourceAsStream(resource);SqlSessionFactory sqlSessionFactory = null;使用 SqlSessionFactoryBuilder 创建 SqlSessionFactory 的一个实例sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputstream);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 源码 </category>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring ApplicationListener 作用</title>
      <link href="/yuan-ma/spring/2020-12-01-spring-applicationlistener-zuo-yong/"/>
      <url>/yuan-ma/spring/2020-12-01-spring-applicationlistener-zuo-yong/</url>
      
        <content type="html"><![CDATA[<h1><span id="spring-applicationlistener-作用">Spring ApplicationListener 作用</span></h1><h3><span id="使用场景">使用场景</span></h3><p>在一些业务场景中，当容器初始化完成之后，需要处理一些操作，比如一些数据的加载、初始化缓存、特定任务的注册等等。这个时候我们就可以使用Spring提供的ApplicationListener来进行操作</p><pre class=" language-language-java"><code class="language-language-java">public class ApplicationStartListener implements ApplicationListener<contextrefreshedevent>{    @Override    public void onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent) {        System.out.println("我的父容器为：" + contextRefreshedEvent.getApplicationContext().getParent());        System.out.println("初始化时我被调用了。");    }}</contextrefreshedevent></code></pre><pre class=" language-language-java"><code class="language-language-java">@Configurationpublic class ListenerConfig {    @Bean    public ApplicationStartListener applicationStartListener(){        return new ApplicationStartListener();    }}</code></pre><p>为啥不直接在ApplicationStartListener类上面加@Component注解?</p><p>​通过配置类ListenerConfig 可以更加直观的去管理项目中已有监听器，对于后面代码维护者更友好</p>]]></content>
      
      
      <categories>
          
          <category> 源码 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>notify和notifyAll区别</title>
      <link href="/java-ji-chu/2020-11-28-notify-he-notifyall-qu-bie/"/>
      <url>/java-ji-chu/2020-11-28-notify-he-notifyall-qu-bie/</url>
      
        <content type="html"><![CDATA[<h1><span id="java-线程-notify和notifyall区别">Java 线程 notify和notifyAll区别</span></h1><p>从字面上意思来说，notify是唤醒一个处于该对象wait的线程<br>而notifyAll是唤醒所有处于该对象wait的线程。<br>但是唤醒不等于就能执行了，需要得到锁对象才能有权利继续执行，而锁只有一把，所以多个线程被唤醒时需要争取该锁。<br>那你也许会想，既然只有一把锁，那我每次用notify唤醒一个不就行了，这样都省的争了，notifyAll还有存在的意义吗？</p><p>事实并不是这样的，这里我就直接用知乎的回答来阐述这个问题。大家一起学习。</p><blockquote><p>先说两个概念：锁池和等待池</p><ul><li>锁池:假设线程A已经拥有了某个对象(注意:不是类)的锁，而其它的线程想要调用这个对象的某个synchronized方法(或者synchronized块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的锁池中。</li><li>等待池:假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁后，进入到了该对象的等待池中<br><a href="http://blog.csdn.net/emailed/article/details/4689220" target="_blank" rel="noopener">Reference：java中的锁池和等待池</a><br>然后再来说notify和notifyAll的区别</li><li>如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。</li><li>当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争</li><li>优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。<br><a href="http://wiki.jikexueyuan.com/project/java-concurrency/collaboration-between-threads.html" target="_blank" rel="noopener">Reference：线程间协作：wait、notify、notifyAll</a><br>综上，所谓唤醒线程，另一种解释可以说是将线程由等待池移动到锁池，notifyAll调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而notify只会唤醒一个线程。<br>有了这些理论基础，后面的notify可能会导致<strong>死锁</strong>，而notifyAll则不会的例子也就好解释了</li></ul></blockquote><hr><p>作者：文龙<br>链接：<a href="https://www.zhihu.com/question/37601861/answer/145545371" target="_blank" rel="noopener">https://www.zhihu.com/question/37601861/answer/145545371</a></p><p>notify会产生死锁？可能你无法理解为什么，就用程序来表达吧。</p><pre><code>package lock;import java.util.concurrent.TimeUnit;/*** @author Alex Wang* @date 2017/12/15*/public class TestNotifyAndNotifyAll {       public static void main(String[] args) {           Object co = new Object();           System.out.println(co);           for (int i = 0; i &lt; 5; i++) {               MyThread t = new MyThread("Thread" + i, co);               t.start();           }           try {               TimeUnit.SECONDS.sleep(2);               System.out.println("-----Main Thread notify-----");               synchronized (co) {                   co.notify();               }               TimeUnit.SECONDS.sleep(2);               System.out.println("Main Thread is end.");           } catch (InterruptedException e) {               e.printStackTrace();           }       }       static class MyThread extends Thread {           private String name;           private Object co;           public MyThread(String name, Object o) {               this.name = name;               this.co = o;           }           @Override           public void run() {               System.out.println(name + " is waiting.");               try {                   synchronized (co) {                       co.wait();                       System.out.println(name +"get lock again");                   }                   System.out.println(name + " has been notified.");               } catch (InterruptedException e) {                   e.printStackTrace();               }           }       }}</code></pre><p>运行该程序会发生死锁，因为main线程中途只唤醒了一个线程，而当那个线程运行完之后就释放了锁，却没有唤醒其余等待的线程进入锁池竞争锁。所以就<br>造成了该现象。解决方法就是讲main线程中的notify改为notifyAll或者在MyThread的run方法中在退出同步块之前进行notify()</p><p>notifyAll should be used most of the time. If you are not sure which to use, then use notifyAll.Please see explanation that follows.<br>大部分情况下都用notifyAll即可，如果你实在不确定用哪个，那就用notifyAll。</p><blockquote><p><strong>参考</strong>:<br><a href="https://www.zhihu.com/question/37601861" target="_blank" rel="noopener">知乎notify和notifyAll的区别</a><br><a href="https://stackoverflow.com/questions/37026/java-notify-vs-notifyall-all-over-again" target="_blank" rel="noopener">Google回答</a></p><p><a href="http://www.zzcblogs.top/2018/03/15/java-notify%E5%92%8CnotifyAll%E5%8C%BA%E5%88%AB/" target="_blank" rel="noopener">java notify和notifyAll区别</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iterm2+oh-my-zsh内容太多时显示不完全</title>
      <link href="/iterm2/mac/2020-11-28-iterm2-oh-my-zsh-nei-rong-tai-duo-shi-xian-shi-bu-wan-quan/"/>
      <url>/iterm2/mac/2020-11-28-iterm2-oh-my-zsh-nei-rong-tai-duo-shi-xian-shi-bu-wan-quan/</url>
      
        <content type="html"><![CDATA[<h1><span id="iterm2oh-my-zsh内容太多时显示不完全">iterm2+oh-my-zsh内容太多时显示不完全</span></h1><ol><li><p>按 command +  ,  唤出 iterm2 设置页面</p></li><li><p>进行如下图设置，修改 Scrollback lines 值</p><p>![设置](/Users/mac/Library/Application Support/typora-user-images/image-20201128200642759.png)</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> iterm2 </category>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oh-my-zsh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程（一）线程通信</title>
      <link href="/java-ji-chu/2020-11-28-xian-cheng-yi-xian-cheng-tong-xin/"/>
      <url>/java-ji-chu/2020-11-28-xian-cheng-yi-xian-cheng-tong-xin/</url>
      
        <content type="html"><![CDATA[<h1><span id="线程一线程通信">线程（一）线程通信</span></h1>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis 源码（一）</title>
      <link href="/mybatis/2020-11-27-mybatis-yuan-ma-yi/"/>
      <url>/mybatis/2020-11-27-mybatis-yuan-ma-yi/</url>
      
        <content type="html"><![CDATA[<h1><span id="mybatis-源码一">Mybatis 源码（一）</span></h1><p>MapperMethod 有两个内容部类：</p><p>SqlCommand 是 MapperMethod 的内部类，</p><p>主要体现在MapperMethod类的execute()方法里,SqlCommand为其提供了查询类型和方法id两个信息,从而使用Sqlseesion执行不同的方法</p><p>MethodSignature 是 MapperMethod 的内部类</p><p>MethodSignature为MapperMethod类提供了三个作用,获取待执行方法中的参数和@Param注解标注的参数名,获取标注有@MapKey的参数(@Mapkey作用在后续会讲到),方法的返回类型,获取SELECT操作时必要的标志位。以下是MethodSignature的所有属性。</p>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring MVC中的Controller是Serlvet吗？</title>
      <link href="/spring/2020-11-23-spring-mvc-zhong-de-controller-shi-serlvet-ma/"/>
      <url>/spring/2020-11-23-spring-mvc-zhong-de-controller-shi-serlvet-ma/</url>
      
        <content type="html"><![CDATA[<h1><span id="spring-mvc中的controller是serlvet吗">Spring MVC中的Controller是Serlvet吗？</span></h1><p>不是。</p><p>Controller 是一个处理请求的 Java bean 。</p><p>DispatcherServlet 是 Spring MVC 中唯一的一个 Servlet ；Servlet容器(Tomcat)把所有请求都转发到DispatcherServlet，然后通过 HandlerMapping 把请求路由到具体的 Controller 中。</p><p>DispatcherServlet 由谁创建：</p><p>DispatcherServlet 的生命周期与普通的 Servlet 一样都是由 Servlet 容器（例如 Tomcat ）管理，在第一次访问时创建，在容器关闭时销毁。显而易见的，DispatcherServlet 实例在 Servlet 容器中，而不是 Spring 自己的 IoC 容器中。</p><p><img src="https://img.nbjike.com/jietu/20201123225705.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 自增 id 的问题</title>
      <link href="/mysql/2020-11-23-mysql-zi-zeng-id-de-wen-ti/"/>
      <url>/mysql/2020-11-23-mysql-zi-zeng-id-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1><span id="mysql-自增-id-的问题">Mysql 自增 id 的问题</span></h1><p>mysql 自增 id 的问题</p><p>先设置id</p><p>再删除表（delete 表，不会修改自增，自增值：只会被大于其值所修改）</p><p>再设置id</p><p>再让id自增</p><p><strong>一、</strong></p><p>truncate 是 DDL 语句，它不存在所谓的 “事务回滚”；</p><p>delete 是 DML 语句，它执行完是可以 rollback 的。</p><p><strong>二、</strong></p><p>truncate table 返回值是 0；</p><p>delete from table 返回值是被删除的行数。</p><p><strong>三、</strong></p><p>InnoDB 支持一个表一个文件，此时：</p><p>truncate 会一次性把表干掉，且不会激活触发器，速度非常快；</p><p>delete from table 则会一行一行删除，会激活触发器，速度比较慢。</p><p><em>画外音：</em><em>delete 数据，是要记录日志的，truncate 表不需要记录日志。</em></p><p><strong>四、</strong></p><p>当表中有列被其它表作为外键 (foreign key) 时：</p><p>truncate 会是失败；</p><p>delete 则会成功。</p><p><em>画外音：</em><em>这类数据删除失败很容易定位问题，因为报错提示简单易懂。</em></p><p><strong>五、</strong></p><p>当表中有自增列是：</p><p>truncate 会使得自增列计数复原；</p><p>delete 所有数据后，自增列计数并不会从头开始。</p><p><em>画外音：</em><em>因此，delete 所有数据后，自增列计数的这个行为，往往不是用户想要的，所以是一个潜在坑。</em></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程和线程的关系</title>
      <link href="/cao-zuo-xi-tong/2020-11-22-jin-cheng-he-xian-cheng-de-guan-xi/"/>
      <url>/cao-zuo-xi-tong/2020-11-22-jin-cheng-he-xian-cheng-de-guan-xi/</url>
      
        <content type="html"><![CDATA[<h1><span id="进程-线程-并发">进程、线程、并发</span></h1><p>概念</p><ul><li><p>进程</p><p><strong>进程是资源分配的最小单位</strong></p></li><li><p>线程</p><p><strong>线程是CPU调度的最小单位</strong></p></li><li><p>并发</p><p>把任务在不同的时间点交给处理器进行处理。在同一时间点，任务并不会同时运行</p></li><li><p>并行</p><p>把每一个任务分配给每一个处理器独立完成。在同一时间点，任务一定是同时运行</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
            <tag> 线程 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 数组</title>
      <link href="/java-ji-chu/java-shu-zu/"/>
      <url>/java-ji-chu/java-shu-zu/</url>
      
        <content type="html"><![CDATA[<h1><span id="java-数组">Java 数组</span></h1><h4><span id="java-中数组是对象证明">Java 中数组是对象，证明：</span></h4><pre class=" language-language-java"><code class="language-language-java">int[] arr = new int[10];System.out.println(arr);// 输出的结果为：[I@5dfcfece 一个对象的地址</code></pre><h4><span id="java-中数组的大小不可变扩容由拷贝实现">Java 中数组的大小不可变，<strong>扩容</strong>由拷贝实现</span></h4><h4><span id="数组初始化的时候可以不指定长度吗">数组初始化的时候可以不指定长度吗？</span></h4><p>可以</p><pre class=" language-language-java"><code class="language-language-java">int[] arr =  new int[] {};等价于int[] arr =  new int[0];等价于int[] arr = {};</code></pre><blockquote><p>大小固定，不能动态扩展(初始化给大了，浪费；给小了，不够用)，插入快，删除和查找慢</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 为什么不能申明成一个基本数据类型的集合？</title>
      <link href="/java-ji-chu/java-wei-shi-me-bu-neng-shen-ming-cheng-yi-ge-ji-ben-shu-ju-lei-xing-de-ji-he/"/>
      <url>/java-ji-chu/java-wei-shi-me-bu-neng-shen-ming-cheng-yi-ge-ji-ben-shu-ju-lei-xing-de-ji-he/</url>
      
        <content type="html"><![CDATA[<h1><span id="java-为什么不能申明成一个基本数据类型的集合">Java 为什么不能申明成一个基本数据类型的集合？</span></h1><h3><span id="解释1">解释1</span></h3><p>通过菱形语法（’&lt;&gt;’）可以将集合内元素的类型限定为E类型。</p><p>需要注意的是 &lt;&gt; 内的类型只能是<strong>引用类型</strong>，当然对于基本类型，可以使用对应的<strong>包装类型</strong>。</p><h3><span id="解释2">解释2</span></h3><p>为什么泛型里面数据类型不能是基本类型呢？</p><p>因为虚拟机在编译时会把带泛型的转换成 Object 类型，而基本类型不属于 Object 类型，所以泛型里面数据类型不能是基本类型。</p><h3><span id="解释3">解释3</span></h3><p>为什么基本类型不属于Object类型呢？</p><p><strong>基本数据类型可以在栈中进行分配，也可以在堆中分配</strong>（基本类型在成员变量和局部（ local ）变量的时候其内存分配机制是不一样的。如果是成员变量，那么不分基本类型和引用类型都是在 java 的堆内存里面分配空间，而局部变量的基本类型是在栈上分配的。栈属于线程私有的空间，局部变量的生命周期和作用域一般都很短，为了提高 gc 效率，所以没必要放在堆里面。）；对象类型在堆中进行分配。</p><p>java 不是 100% 的面向对象编程，比如基本数据类型如 int , boolean 等等都不是对象，也就是不能用 new 的方式获取，但是 java 对这些基本数据类型都有解决办法，就是对着一个封装类型，他们的封装类是对象。比如 int 对应着 Integer , boolean 对应着 Boolean ,他们都是为了解决基本数据类型面向对象用的。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基本数据类型 </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 保存密码</title>
      <link href="/article/git-bao-cun-mi-ma/"/>
      <url>/article/git-bao-cun-mi-ma/</url>
      
        <content type="html"><![CDATA[<h1><span id="git-保存密码">Git 保存密码</span></h1><h3><span id="编辑git文件">编辑git文件</span></h3><p><strong>进入git项目根目录</strong>：<br>1、linux : vi .git/config 于文件末尾添加内容，并保存</p><pre><code>[credential]           helper = store </code></pre><p>拉取或提交过一次代码后，会自动保存密码～</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot 整合 Redisson</title>
      <link href="/article/springboot-zheng-he-redisson/"/>
      <url>/article/springboot-zheng-he-redisson/</url>
      
        <content type="html"><![CDATA[<h1><span id="springboot-整合-redisson">Springboot 整合 Redisson</span></h1><h3><span id="1-添加-maven-依赖">1. 添加 Maven 依赖</span></h3><pre class=" language-language-xml"><code class="language-language-xml">        <!--redis-->        <dependency>            <groupid>org.springframework.boot</groupid>            <artifactid>spring-boot-starter-data-redis</artifactid>        </dependency>        <!--redisson-->        <dependency>            <groupid>org.redisson</groupid>            <artifactid>redisson-spring-boot-starter</artifactid>            <version>3.10.6</version>        </dependency></code></pre><h3><span id="2-书写配置文件">2. 书写配置文件</span></h3><pre class=" language-language-yaml"><code class="language-language-yaml">redis:  host: 127.0.0.1  port: 11328  password: wawaji</code></pre><h3><span id="3-书写配置类">3. 书写配置类</span></h3><pre class=" language-language-java"><code class="language-language-java">@Configurationpublic class RedissonConfig {  @Value("${redis.host}")  private String host;  @Value("${redis.port}")  private String port;  @Value("${redis.password}")  private String password;  @Bean  public RedissonClient redissonClient() {    Config config = new Config();    //单节点    SingleServerConfig singleServerConfig = config.useSingleServer();    singleServerConfig.setAddress("redis://" + host + ":" + port);    if (StringUtils.isEmpty(password)) {      singleServerConfig.setPassword(null);    } else {      singleServerConfig.setPassword(password);    }//添加主从配置// config.useMasterSlaveServers().setMasterAddress("").setPassword("").addSlaveAddress(new String[]{"",""});// 集群模式配置 setScanInterval()扫描间隔时间，单位是毫秒, //可以用"rediss://"来启用SSL连接// config.useClusterServers().setScanInterval(2000).addNodeAddress("redis://127.0.0.1:7000", "redis://127.0.0.1:7001").addNodeAddress("redis://127.0.0.1:7002");    return Redisson.create(config);  }}</code></pre><h3><span id="4-编写操作方法类">4. 编写操作方法类</span></h3><p><strong>接口：</strong></p><pre class=" language-language-java"><code class="language-language-java">void getRedissonClient() throws IOException;    /**     * 获取字符串对象     *     * @param objectName     * @return     */    <t> RBucket<t> getRBucket(String objectName);    /**     * 获取Map对象     *     * @param objectName     * @return     */    <k, v> RMap<k, v> getRMap(String objectName);    /**     * 获取有序集合     *     * @param objectName     * @return     */    <v> RSortedSet<v> getRSortedSet(String objectName);    /**     * 获取集合     *     * @param objectName     * @return     */    <v> RSet<v> getRSet(String objectName);    /**     * 获取列表     *     * @param objectName     * @return     */    <v> RList<v> getRList(String objectName);    /**     * 获取队列     *     * @param objectName     * @return     */    <v> RQueue<v> getRQueue(String objectName);    /**     * 获取双端队列     *     * @param objectName     * @return     */    <v> RDeque<v> getRDeque(String objectName);    /**     * 获取锁     *     * @param objectName     * @return     */    RLock getRLock(String objectName);    /**     * 获取读写锁     *     * @param objectName     * @return     */    RReadWriteLock getRWLock(String objectName);    /**     * 获取原子数     *     * @param objectName     * @return     */    RAtomicLong getRAtomicLong(String objectName);    /**     * 获取记数锁     *     * @param objectName     * @return     */    RCountDownLatch getRCountDownLatch(String objectName);    /**     * 获取消息的Topic     *     * @param objectName     * @return     */    RTopic getRTopic(String objectName);</v></v></v></v></v></v></v></v></v></v></k,></k,></t></t></code></pre><p><strong>实现类：</strong></p><pre class=" language-language-java"><code class="language-language-java">@Componentpublic class RedisCacheImpl implements RedisCache {    @Resource    private RedissonClient redissonClient;    @Override    public void getRedissonClient() throws IOException {        Config config = redissonClient.getConfig();        System.out.println(config.toJSON());    }    /**     *     * 获取字符串对象     *     * @param objectName     * @return     */    @Override    public <t> RBucket<t> getRBucket(String objectName) {        return redissonClient.getBucket(objectName);    }    /**     * 获取Map对象     *     * @param objectName     * @return     */    @Override    public <k, v> RMap<k, v> getRMap(String objectName) {        RMap<k, v> map = redissonClient.getMap(objectName);        return map;    }    /**     * 获取有序集合     *     * @param objectName     * @return     */    @Override    public <v> RSortedSet<v> getRSortedSet(String objectName) {        RSortedSet<v> sortedSet = redissonClient.getSortedSet(objectName);        return sortedSet;    }    /**     * 获取集合     *     * @param objectName     * @return     */    @Override    public <v> RSet<v> getRSet(String objectName) {        RSet<v> rSet = redissonClient.getSet(objectName);        return rSet;    }    /**     * 获取列表     *     * @param objectName     * @return     */    @Override    public <v> RList<v> getRList(String objectName) {        RList<v> rList = redissonClient.getList(objectName);        return rList;    }    /**     * 获取队列     *     * @param objectName     * @return     */    @Override    public <v> RQueue<v> getRQueue(String objectName) {        RQueue<v> rQueue = redissonClient.getQueue(objectName);        return rQueue;    }    /**     * 获取双端队列     *     * @param objectName     * @return     */    @Override    public <v> RDeque<v> getRDeque(String objectName) {        RDeque<v> rDeque = redissonClient.getDeque(objectName);        return rDeque;    }    /**     * 获取锁     *     * @param objectName     * @return     */    @Override    public RLock getRLock(String objectName) {        RLock rLock = redissonClient.getLock(objectName);        return rLock;    }    /**     * 获取读写锁     *     * @param objectName     * @return     */    @Override    public RReadWriteLock getRWLock(String objectName) {        RReadWriteLock rwlock = redissonClient.getReadWriteLock(objectName);        return rwlock;    }    /**     * 获取原子数     *     * @param objectName     * @return     */    @Override    public RAtomicLong getRAtomicLong(String objectName) {        RAtomicLong rAtomicLong = redissonClient.getAtomicLong(objectName);        return rAtomicLong;    }    /**     * 获取记数锁     *     * @param objectName     * @return     */    @Override    public RCountDownLatch getRCountDownLatch(String objectName) {        RCountDownLatch rCountDownLatch = redissonClient.getCountDownLatch(objectName);        return rCountDownLatch;    }    /**     * 获取消息的Topic     *     * @param objectName     * @return     */    @Override    public RTopic getRTopic(String objectName) {        RTopic rTopic = redissonClient.getTopic(objectName);        return rTopic;    }}</v></v></v></v></v></v></v></v></v></v></v></v></v></v></v></k,></k,></k,></t></t></code></pre><h3><span id="5-编写测试类">5. 编写测试类</span></h3><pre class=" language-language-java"><code class="language-language-java">@Resourceprivate RedisCache redisCache;@Testpublic void testCache() {    RBucket<object> k1 = redisCache.getRBucket("k1");    System.out.println(k1.get());}</object></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Content-Type 了解</title>
      <link href="/article/content-type-liao-jie/"/>
      <url>/article/content-type-liao-jie/</url>
      
        <content type="html"><![CDATA[<h1><span id="content-type-了解">Content-Type 了解</span></h1><h2><span id="content-type">Content-Type</span></h2><p>Content-Type:实体头部用于指示资源的MIME类型。如果未指定 ContentType，默认为text/html 有两种场景： 在请求中 (如POST 或 PUT)，客户端告诉<strong>服务器</strong>实际发送的数据类型。</p><p>在响应中，Content-Type标头告诉<strong>客户端</strong>实际返回的内容的内容类型。<strong>浏览器</strong>会在某些情况下进行MIME查找，并不一定遵循此标题的值; 为了防止这种行为，可以将标题 X-Content-Type-Options 设置为 nosniff。</p><p>简而言之就是标识资源或者所需资源的MIME类型。</p><p>句法如下：</p><pre><code>Content-Type: text/html; charset=utf-8Content-Type: multipart/form-data; boundary=something</code></pre><p>参数一般media-type、charset、boundary三种。 我们的关注点在于media-type的取值以及其适用场景。</p><h3><span id="media-type">media-type</span></h3><p>更多的是作为MIME type( Multipurpose Internet Mail Extensions)出现，即多用途Internet邮件扩展。<br>其目的是用一种标准化的方式来标识文档的性质和格式。<br>浏览器通常使用MIME类型（而不是文件扩展名）来确定如何处理文档；<br>因此服务器设置正确以将正确的MIME类型附加到响应对象的头部是非常重要的。</p><h4><span id="结构">结构</span></h4><p>MIME 组成结构如下： 由类型与子类型两个字符串中间用’/'分隔而组成。不允许空格存在。对大小写不敏感，但传统都是小写。 允许额外参数，如后面所示：</p><pre><code>type/subtype;parameter=value</code></pre><p>其中：</p><ul><li>type对应通用类目，例如：text，video等。</li><li>subtype对应准确的子类，例如text下面细分为plain(纯文本)、html(html源码)、calendar（.ics）文件等。</li><li>parameter可选一般是charset或者bundaary等。</li></ul><h3><span id="types">Types</span></h3><p>类目包括两种类型：独立类型和Multipart类型。</p><h4><span id="独立类型">独立类型</span></h4><p>独立类型指只代表一个单独的文件或者媒体的类型，表明了对文件的分类。 常见类型和实例如下：</p><ul><li>text 文本数据包括一些人类可读的内容或者源码。例如：text/plain, text/csv, text/html.</li><li>application 数据为二进制的一种，例如：application/json,application/octet-stream,application/pdf,application/pkcs8,application/zip.</li><li>audio 音频或者音乐数据，例如audio/mpeg, audio/vorbis</li><li>video 视频数据或者文件，例如video/mp4</li><li>image 图像或图形数据，包括位图和矢量静止图像以及静止图像格式的动画版本。例如image/gif, image/png, image/jpeg, image/bmp, image/webp, image/x-icon</li></ul><h4><span id="multipart类型">Multipart类型</span></h4><p>Multipart类型指明被分为几部分的一种文档的类目，且经常有不同的MIME类型。也可以用来表示属于相同事物的多个且独立的文件，这些独立的文件构成一个复杂的文档。在电子邮件场景中常见。<br>有两种Multipart类型：message和multipart。</p><ul><li>message 一个包括其他信息的消息，常用于下面的场景，例如指明一个邮件包含转发信息或者在多种信息的情况下，允许以chunk的形式发送数据量很大的信息。包括message/rfc822和message/partial</li><li>multipart<br>由多个不同MIME类型组件构成的数据，例如 multipart/form-data(使用FormData API生成的数据)</li></ul><h3><span id="常见类型及使用场景">常见类型及使用场景</span></h3><h4><span id="application类">application类</span></h4><ul><li><p><strong>application/json</strong></p><p>随着json这种轻量级的数据交互格式的流行，特别是和脚本交互的便利，使得在前后接口中，越来越多采用json格式。对于http协议来说，<strong>最终传输的还是字符。</strong></p></li><li><p><strong>application/x-www-form-urlencoded</strong> 作为表单提交中默认的类型，其表明数据以标准的编码格式被编码为键值对。 数据被编码成以 ‘&amp;’ 分隔的键-值对, 同时以 ‘=’ 分隔键和值. 非字母或数字的字符会被 percent-encoding: 这也就是为什么这种类型不支持二进制数据的原因 (应使用 multipart/form-data 代替).</p></li><li><p><strong>multipart/form-data</strong><br>一般用于涉及文件的表单提交，用于post请求，其格式如下：</p><pre><code>Content-Type: multipart/form-data; boundary=aBoundaryString</code></pre></li></ul><p>其中boundary指明了请求体中每部分的分割符(对于multipart的类目，都会存在该字段，以区分请求体中数据的分割)，其请求体中则是对应表单每部分的内容。每部分都会有自己的请求体和相关内容。</p><ul><li><strong>application/javascript application/x-javascript text/javascript</strong><br>对于js文件，常见MIME类型为text/javascript，但是前两种应该会有见到过。三者之间多少还是有点区别的。<br>传统的js程序对应的MIME类型为text/javascript，其他的还有"application/x-javascript"（x前缀表示这是实验性类型）， 因为text/javascript是最常见的类型，所以RFC4329定义了“text/javascript”。不过，js文件实际上并不是真正的文本类型，因此推出了application/javascript类型，不过现行的支持性并不好，所以常常会用application/x-javascript来代替。</li><li><strong>application/zip application/gzip</strong><br>zip 对应zip压缩文件，gzip是若干种文件压缩程序的简称，通常指GNU计划的实现，此处的gzip代表GNU zip。</li><li><strong>application/http</strong><br>从类型可以知道，是http请求，但具体用途还是要翻下<a href="https://www.iana.org/assignments/media-types/application/http" target="_blank" rel="noopener">规范</a>才能找到的。<br>此类型包含的http请求包含在binary消息体中，在邮件协议传输中需要指明Content-Transfer-Encoding。</li></ul><h4><span id="multipart类型">multipart类型</span></h4><p>multipart一般对应单个消息头对应多个消息体。 常见语法如下:</p><pre><code>Content-Type: multipart/mixed; boundary=gc0p4Jq0M2Yt08jU534c0p</code></pre><p>其中boundary字段是必须的，用于区分消息体中的数据边界，一般是两个’-'的格式作为该端的开头，例如：</p><pre><code>--gc0p4Jq0M2Yt08jU534c0p</code></pre><p>常见的有以下几种类型</p><ul><li><p><strong>multipart/form-data</strong></p></li><li><p><strong>multipart/mixed</strong></p></li><li><p><strong>multipart/alternative</strong></p></li></ul><h3><span id="参考">参考</span></h3><p><a href="http://www.ruanyifeng.com/blog/2008/06/mime.html" target="_blank" rel="noopener">www.ruanyifeng.com/blog/2008/0…</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot maven-plugin</title>
      <link href="/article/springboot-maven-plugin/"/>
      <url>/article/springboot-maven-plugin/</url>
      
        <content type="html"><![CDATA[<h1><span id="springboot-maven-plugin">Springboot maven-plugin</span></h1><pre><code>&lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                &lt;!--将本地的jar也打到生成的包中--&gt;                    &lt;includeSystemScope&gt;true&lt;/includeSystemScope&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;            &lt;!--mybatis 逆向工具--&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;                &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;1.3.3&lt;/version&gt;                &lt;dependencies&gt;                    &lt;dependency&gt;                        &lt;groupId&gt;springboot&lt;/groupId&gt;                        &lt;artifactId&gt;common&lt;/artifactId&gt;                        &lt;version&gt;1.0.0&lt;/version&gt;                    &lt;/dependency&gt;                &lt;/dependencies&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;</code></pre><p>spring-boot-maven-plugin : 要放在<strong>主启动类</strong>对应的pom下</p>]]></content>
      
      
      
        <tags>
            
            <tag> 坑 </tag>
            
            <tag> Springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Neo4j整合 Springboot</title>
      <link href="/article/neo4j-zheng-he-springboot/"/>
      <url>/article/neo4j-zheng-he-springboot/</url>
      
        <content type="html"><![CDATA[<h1><span id="neo4j整合-springboot">Neo4j整合 Springboot</span></h1>]]></content>
      
      
      
        <tags>
            
            <tag> Neo4j </tag>
            
            <tag> 图数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot 引入外部jar的坑</title>
      <link href="/article/springboot-yin-ru-wai-bu-jar-de-keng/"/>
      <url>/article/springboot-yin-ru-wai-bu-jar-de-keng/</url>
      
        <content type="html"><![CDATA[<h1><span id="springboot-引入外部jar的坑">Springboot 引入外部jar的坑</span></h1><h4><span id="前言由于项目需求短信验证码的接口需要换成阿里大于的但是尴尬的发现阿里大于的jar包没有maven版本的于是便开始了一上午的操蛋引包之路-按照套路来说自然应该是百度一波但是百度了好久找了好多方案之后发现没一个有用的而且文章的抄袭-拷贝十分严重试了n种方案都是错的都没有将外部jar包打包到book-inf文件夹下-最终在第n次尝试之后终于在打的jar包里将外部的jar包导入进来-特此记录下防止再犯">前言:由于项目需求，短信验证码的接口需要换成阿里大于的，但是尴尬的发现阿里大于的jar包没有maven版本的，于是便开始了一上午的操蛋引包之路。按照套路来说，自然应该是百度一波，但是百度了好久，找了好多方案之后发现，没一个有用的，而且文章的抄袭、拷贝十分严重，试了N种方案，都是错的，都没有将外部jar包打包到BOOK-INF文件夹下。最终，在第N次尝试之后，终于在打的jar包里将外部的jar包导入进来。特此记录下，防止再犯！！！</span></h4><p>首先在新建libs文件夹（根目录或者resource目录下都可以），将需要引入的jar放进去</p><img src="https://img.nbjike.com/jietu/20200627211044.png" style="zoom:50%;"><p>然后再pom中加入如下配置，告诉maven导入本地jar</p><pre><code>&lt;dependency&gt;        &lt;groupId&gt;com.aliyun&lt;/groupId&gt;        &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt;        &lt;version&gt;3.2.2&lt;/version&gt;        &lt;scope&gt;system&lt;/scope&gt;        &lt;systemPath&gt;${project.basedir}/libs/aliyun-java-sdk-core-3.3.1.jar&lt;/systemPath&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.aliyun&lt;/groupId&gt;        &lt;artifactId&gt;aliyun-java-sdk-dysmsapi&lt;/artifactId&gt;        &lt;version&gt;1.0.0&lt;/version&gt;        &lt;scope&gt;system&lt;/scope&gt;        &lt;systemPath&gt;${project.basedir}/libs/aliyun-java-sdk-dysmsapi-1.0.0.jar&lt;/systemPath&gt;    &lt;/dependency&gt;复制代码</code></pre><p>其中除了systemPath配置告诉maven引入的本地jar包的位置之外，其他的配置都可以随便写</p><p>划重点！！！敲黑板！！！下面的一步配置也是最重要的一步，网上很多的教程缺了这样一步之后就会导致虽然本地可以运行，但是只要使用maven打包就不行，因为maven没有将本地的jar也打到生成的包中</p><p>在pom中给spring boot的打包插件设置一下includeSystemScope参数即可</p><pre><code>&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;configuration&gt;                &lt;includeSystemScope&gt;true&lt;/includeSystemScope&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 坑 </tag>
            
            <tag> Springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能测试工具 wrk</title>
      <link href="/article/xing-neng-ce-shi-gong-ju-wrk/"/>
      <url>/article/xing-neng-ce-shi-gong-ju-wrk/</url>
      
        <content type="html"><![CDATA[<h1><span id="性能测试工具-wrk">性能测试工具 wrk</span></h1><h3><span id="macos-安装">MacOS 安装</span></h3><p>Mac 系统也可以通过先编译的方式来安装，但是更推荐使用 <code>brew</code> 的方式来安装, 步骤如下：</p><ol><li>安装 Homebrew，安装方式参考官网 <a href="https://brew.sh/" target="_blank" rel="noopener">https://brew.sh</a> （也就一行命令的事）;</li><li>安装 wrk: <code>brew install wrk</code>;</li></ol><h3><span id="验证一下是否安装成功">验证一下，是否安装成功</span></h3><pre class=" language-language-sh"><code class="language-language-sh">wrk -v</code></pre><p><img src="https://img.nbjike.com/jietu/20200604231106.png" alt>出现如图所示安装成功</p><h3><span id="简单使用">简单使用</span></h3><pre class=" language-language-cmd"><code class="language-language-cmd">wrk -t12 -c400 -d30s http://www.baidu.com</code></pre><p>这条命令表示，利用 wrk 对 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 发起压力测试，线程数为 12，模拟 400 个并发请求，持续 30 秒</p>]]></content>
      
      
      
        <tags>
            
            <tag> wrk </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从0开始搭建自己的个人博客</title>
      <link href="/article/cong-0-kai-shi-da-jian-zi-ji-de-ge-ren-bo-ke/"/>
      <url>/article/cong-0-kai-shi-da-jian-zi-ji-de-ge-ren-bo-ke/</url>
      
        <content type="html"><![CDATA[<h1><span id="从0开始搭建自己的个人博客">从0开始搭建自己的个人博客</span></h1><ol><li><p>第一步首先下载安装 nodejs  <a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/</a></p><p>成功标志：node -v 有版本号</p><p>​    npm  -v 有版本号</p><p>git 也需要</p></li><li><p>由于 npm 包管理下载的速度有点慢，则需要切换成 阿里的cnpm</p><p>npm install -g cnpm --registry=https://registry.npm.tao.org/</p><p>ok 后就可以使用 cnpm</p></li><li><p>安装hexo</p><p>cnpm install -g hexo-cli</p><p>成功标志 hexo -v</p></li><li><p>搭建</p><p>创建一个 blog 的文件夹</p><p>进入这个文件夹使用命令行 hexo init</p><p>会自动去克隆一个主题</p></li><li><p>启动</p><p>hexo -s</p><p>浏览器访问：localhost:4000</p></li><li><p>新建一篇文章</p><p>hexo n “文件名称”</p><p>文章会出现在…\blog\source_posts 目录下</p><p>编辑文件</p></li><li><p>hexo -g 会生成文章</p></li><li><p>部署到 GitHub 上，使用GitHub page</p><p>在 GitHub 上新建一个仓库，仓库的名称为你的 github 的昵称</p></li><li><p>在刚刚的 blog 目录下安装一个 git 插件</p><p>cnpm install --save hexo-deployer-git</p><p>cnpm install  hexo-deployer-git --save</p></li><li><p>打开 _config.yml 配置相关配置</p><p>在文件的最下面</p><p>添加</p><p>type：git</p><p>​       repo：仓库地址</p><p>branch：master</p></li><li><p>hexo -d</p><p>github账号</p><p>github密码</p></li><li><p>hexo 换主题</p><p>git clone 别人的主题 到 themes 目录中</p><p>修改 _config.yml 文件</p><p>把theme：修改成刚刚克隆下来的文件名</p></li><li><p>hexo -d 重新推到远端去</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 换源</title>
      <link href="/article/go-huan-yuan/"/>
      <url>/article/go-huan-yuan/</url>
      
        <content type="html"><![CDATA[<h1><span id="goproxy-中国">Goproxy 中国</span></h1><p>中国最可靠的 Go 模块代理。</p><p>Goproxy 中国完全实现了 Go 的<a href="https://golang.org/cmd/go/#hdr-Module_proxy_protocol" target="_blank" rel="noopener">模块代理协议</a>。并且它是一个由中国备受信赖的云服务提供商<a href="https://www.qiniu.com/" target="_blank" rel="noopener">七牛云</a>支持的非营利性项目。我们的目标是为中国和世界上其他地方的 Gopher 们提供一个免费的、可靠的、持续在线的且经过 CDN 加速的模块代理。请在 <a href="https://status.goproxy.cn/" target="_blank" rel="noopener">status.goproxy.cn</a> 订阅我们的有关系统性能的实时和历史数据。</p><p>请注意，Goproxy 中国只专注于服务在 <a href="https://goproxy.cn/" target="_blank" rel="noopener">https://goproxy.cn</a> 的 Web 应用本身的开发。如果你正在寻找一种极其简单的方法来搭建你自己的 Go 模块代理，那么你应该看一下 <a href="https://github.com/goproxy/goproxy" target="_blank" rel="noopener">Goproxy</a>，Goproxy 中国就是基于它开发的。</p><p>愉快地编码吧，Gopher 们！;-)</p><p><strong><em>注意，为了帮助 Gopher 们更好地去使用 Go 模块，Goproxy 中国现在支持回答和 Go 模块相关的所有问题（不再只是和 Go 模块代理相关的），你只需要遵循 Issue 模版将问题发表在<a href="https://github.com/goproxy/goproxy.cn/issues/new?assignees=&amp;labels=&amp;template=new-question.zh-CN.md&amp;title=%E9%97%AE%E9%A2%98%EF%BC%9A" target="_blank" rel="noopener">这里</a>即可。别忘了先去检查我们的<a href="https://goproxy.cn/faq" target="_blank" rel="noopener">常见问题</a>页面中是否已经有了你想要询问的问题。</em></strong></p><h2><span id="用法">用法</span></h2><h3><span id="go-113-及以上推荐">Go 1.13 及以上（推荐）</span></h3><p>打开你的终端并执行</p><pre><code>$ go env -w GO111MODULE=on$ go env -w GOPROXY=https://goproxy.cn,direct</code></pre><p>完成。</p><h3><span id="macos-或-linux">macOS 或 Linux</span></h3><p>打开你的终端并执行</p><pre><code>$ export GO111MODULE=on$ export GOPROXY=https://goproxy.cn</code></pre><p>或者</p><pre><code>$ echo "export GO111MODULE=on" &gt;&gt; ~/.profile$ echo "export GOPROXY=https://goproxy.cn" &gt;&gt; ~/.profile$ source ~/.profile</code></pre><p>完成。</p><h3><span id="windows">Windows</span></h3><p>打开你的 PowerShell 并执行</p><pre><code>C:\&gt; $env:GO111MODULE = "on"C:\&gt; $env:GOPROXY = "https://goproxy.cn"</code></pre><p>或者</p><pre><code>1. 打开“开始”并搜索“env”2. 选择“编辑系统环境变量”3. 点击“环境变量…”按钮4. 在“&lt;你的用户名&gt; 的用户变量”章节下（上半部分）5. 点击“新建…”按钮6. 选择“变量名”输入框并输入“GO111MODULE”7. 选择“变量值”输入框并输入“on”8. 点击“确定”按钮9. 点击“新建…”按钮10. 选择“变量名”输入框并输入“GOPROXY”11. 选择“变量值”输入框并输入“https://goproxy.cn”12. 点击“确定”按钮</code></pre><p>完成。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gin——快速入门</title>
      <link href="/article/gin-kuai-su-ru-men/"/>
      <url>/article/gin-kuai-su-ru-men/</url>
      
        <content type="html"><![CDATA[<h1><span id="gin快速入门">Gin——快速入门</span></h1><ol><li><p>通过 govendor（<a href="https://github.com/kardianos/govendor" target="_blank" rel="noopener">管理包依赖工具</a>) 来安装 Gin</p><pre class=" language-language-sh"><code class="language-language-sh">go get github.com/kardianos/govendor</code></pre></li><li><p><code>cd /usr/local/go/path</code>（第三方依赖包，会默认安装在GOPATH的第一个目录下）</p></li><li><p>把 govendor 配置到加入环境变量中</p><ul><li><p>配置环境变量的方式</p></li><li><p>直接移动文件的方式：</p><pre class=" language-language-sh"><code class="language-language-sh">mv /usr/local/go/path/bin/govendor /usr/local/go/bin/</code></pre></li></ul></li><li><pre class=" language-language-sh"><code class="language-language-sh">#govendor -version$ v1.0.9</code></pre></li><li><p>安装Gin</p><pre class=" language-language-sh"><code class="language-language-sh">go get -u github.com/gin-gonic/gin</code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Gin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac 开发软件</title>
      <link href="/article/mac-kai-fa-ruan-jian/"/>
      <url>/article/mac-kai-fa-ruan-jian/</url>
      
        <content type="html"><![CDATA[<h1><span id="mac-开发软件">Mac 开发软件</span></h1><ol><li><p>隐藏 macOS 状态栏图标的工具，使状态栏看起来更整洁</p><blockquote><p><a href="https://github.com/Mortennn/Dozer" target="_blank" rel="noopener">https://github.com/Mortennn/Dozer</a></p></blockquote></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Neo4j学习 环境搭建</title>
      <link href="/article/neo4j-xue-xi-huan-jing-da-jian/"/>
      <url>/article/neo4j-xue-xi-huan-jing-da-jian/</url>
      
        <content type="html"><![CDATA[<h1><span id="neo4j学习-环境搭建">Neo4j学习 环境搭建</span></h1><ol><li><p>安装 docker</p></li><li><p>docker 拉取 neo4j 最新镜像</p><pre class=" language-language-dockerfile"><code class="language-language-dockerfile">docker pull neo4j</code></pre></li><li><p>docker run</p><pre class=" language-language-dockerfile"><code class="language-language-dockerfile">docker run \    -it -d\    --publish=7474:7474 --publish=7687:7687 \    --volume=$HOME/neo4j/data:/data \    --volume=$HOME/neo4j/logs:/logs \    --volume=$HOME/neo4j/conf:/var/lib/neo4j/conf \    --volume=$HOME/neo4j/plugins:/var/lib/neo4j/plugins \    neo4j:latest</code></pre></li><li><p>访问</p><blockquote><p><a href="http://127.0.0.1:7474" target="_blank" rel="noopener">http://127.0.0.1:7474</a></p></blockquote><p>输入账号密码，默认 neo4j neo4j</p><p>改：neo4j , 名字</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Neo4j </tag>
            
            <tag> 图数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Liunx 批量执行curl命令</title>
      <link href="/article/liunx-pi-liang-zhi-xing-curl-ming-ling/"/>
      <url>/article/liunx-pi-liang-zhi-xing-curl-ming-ling/</url>
      
        <content type="html"><![CDATA[<h1><span id="liunx-批量执行curl命令">Liunx 批量执行curl命令</span></h1><ol><li><p>一些url</p><pre><code>https://girl.nbjike.com/http://nuxt.nbjike.com/...</code></pre></li><li><p>创建一个存储 url 的文件</p><pre class=" language-language-sh"><code class="language-language-sh">vim url.txt</code></pre></li><li><p>将相关 url 保存进 url.txt 中</p></li><li><p>终端执行以下命令</p><pre class=" language-language-sh"><code class="language-language-sh">for URL in `cat url.txt`; do echo $URL; curl -m 10 -s -I $1 "$URL" | grep HTTP/1.1 |  awk {'print $2'}; done</code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Liunx 相关命令操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nuxt asyncData() 方法详解</title>
      <link href="/article/nuxt-asyncdata-fang-fa-xiang-jie/"/>
      <url>/article/nuxt-asyncdata-fang-fa-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h1><span id="nuxt-asyncdata-方法详解">Nuxt asyncData() 方法详解</span></h1><h4><span id="细节一">细节一：</span></h4><p>​<strong>异步数据 （asyncData方法，限于page页面组件，components中不适用）</strong></p><h4><span id="细节二">细节二：</span></h4>]]></content>
      
      
      
        <tags>
            
            <tag> Nuxt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nuxt SEO初体验</title>
      <link href="/article/nuxt-seo-chu-ti-yan/"/>
      <url>/article/nuxt-seo-chu-ti-yan/</url>
      
        <content type="html"><![CDATA[<h1><span id="nuxt-seo初体验">Nuxt SEO初体验</span></h1><ol><li><p>什么是 SEO</p><p>SEO，这个词从宽泛的意义上讲，也叫 SEO优化，也叫网站优化，也叫搜索引擎优化</p><p>SEO，称是：Search Engine Optimization，中文为搜索引擎优化</p><p>说人话就是：怎样让你的网站被更多的网友搜索到</p></li><li><p>Nuxt  SEO 初体验</p><ol><li><p>修改 nuxt.config.js</p><pre class=" language-language-js"><code class="language-language-js">   head: {        title: '跳蚤的 nuxt 学习网站',        meta: [            {charset: 'utf-8'},            {name: 'viewport', content: 'width=device-width, initial-scale=1'},            {hid: 'description', name: 'description', content: '跳蚤的 nuxt 学习网站，淘宝、小红书、知乎'}        ],        link: [ //  favicon，若引用css不会进行打包处理            {rel: 'icon', type: 'image/x-icon', href: '/dog.ico'}        ]   }</code></pre></li><li><p>修改每个页面的</p><pre class=" language-language-js"><code class="language-language-js">head(){    return {      title: '子页面中的标题',      meta: [{        hid: "description",        name: "description",        content: "this is 子页面 描述"      },{        hid: 'viewport',        name: 'viewport',        content: 'width=device-width, initial-scale=1.0'      }]    }  }</code></pre></li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> axios </tag>
            
            <tag> Nuxt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nuxt 服务端渲染调用接口</title>
      <link href="/article/nuxt-fu-wu-duan-xuan-ran-diao-yong-jie-kou/"/>
      <url>/article/nuxt-fu-wu-duan-xuan-ran-diao-yong-jie-kou/</url>
      
        <content type="html"><![CDATA[<h1><span id="nuxt-服务端渲染调用接口">Nuxt 服务端渲染调用接口</span></h1><h3><span id="axios的使用">axios的使用</span></h3><ol><li><p>安装<code>npm install --save axios</code></p></li><li><p>使用</p><ol><li><p>方式1</p><pre class=" language-language-js"><code class="language-language-js">import axios from 'axios'asyncData(context, callback) {  axios.get('http://localhost:3301/in_theaters')    .then(res => {      console.log(res);      callback(null, {list: res.data})    })}</code></pre></li><li><p>方式2</p><pre class=" language-language-js"><code class="language-language-js"> import axios from "axios";    export default {        props: {},        data() {            return {}        }        async asyncData() {            let url = "http://localhost:3301/in_theaters";            return await axios.get(url, {                headers: {                    "X-ACCESS-KEY": "xxx"                }            })                .then(res => {                    return {data: res.data}                }).catch(reason => {                    console.log(reason)                })        }    </code></pre></li></ol></li></ol><ol start="3"><li><p>为防止重复打包，在nuxt.config.js中配置</p><pre class=" language-language-js"><code class="language-language-js">module.exports = {  build: {    vendor: ['axios']  }}</code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> axios </tag>
            
            <tag> Nuxt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nuxt 快速入门</title>
      <link href="/article/nuxt-kuai-su-ru-men/"/>
      <url>/article/nuxt-kuai-su-ru-men/</url>
      
        <content type="html"><![CDATA[<h1><span id="nuxt-快速入门">Nuxt 快速入门</span></h1><ol><li><p>修改 index.vue 下原有的内</p></li><li><p>写三个标签，用于连接到其他页面</p><pre class=" language-language-html"><code class="language-language-html"><template>    <div>        <!--   用于跳转页面     -->        <nuxt-link to="/tb/tb" target="_blank">淘宝</nuxt-link>        <nuxt-link to="/zhihu/zhihu" target="_blank">知乎</nuxt-link>        <nuxt-link to="/xhs/xhs" target="_blank">小红书</nuxt-link>    </div></template></code></pre></li><li><p>编写 tb 页面（nuxt 会自动生成路径：/tb/tb）</p><p><img src="https://img.nbjike.com/jietu/20200517143424.png" alt></p></li><li><p>编写 tb.vue 内相关内容</p><pre class=" language-language-html"><code class="language-language-html"><template>    <div class="tb">        {{ data }}    </div></template></code></pre></li><li><p>运行</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Nuxt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go基本语法——快速入门</title>
      <link href="/article/go-ji-ben-yu-fa-kuai-su-ru-men/"/>
      <url>/article/go-ji-ben-yu-fa-kuai-su-ru-men/</url>
      
        <content type="html"><![CDATA[<h1><span id="go基本语法快速入门">Go基本语法——快速入门</span></h1>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Npm 卸载eslint</title>
      <link href="/article/npm-xie-zai-eslint/"/>
      <url>/article/npm-xie-zai-eslint/</url>
      
        <content type="html"><![CDATA[<h1><span id="npm-卸载eslint">Npm 卸载eslint</span></h1><ol><li><p>查看当前目录安装了哪些 npm 依赖包</p><pre class=" language-language-sh"><code class="language-language-sh">npm list --depth=0或npm list或npm list --depth --global</code></pre></li><li><p>删除对应的模块</p><pre class=" language-language-sh"><code class="language-language-sh">npm uninstall 模块&nbsp;删除本地模块时你应该思考的问题：是否将在package.json上的相应依赖信息也消除？npm uninstall 模块：删除模块，但不删除模块留在package.json中的对应信息npm uninstall 模块 --save&nbsp;删除模块，同时删除模块留在package.json中dependencies下的对应信息npm uninstall 模块 --save-dev&nbsp;删除模块，同时删除模块留在package.json中devDependencies下的对应信息</code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Node </tag>
            
            <tag> Npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nuxt 环境搭建</title>
      <link href="/article/nuxt-huan-jing-da-jian/"/>
      <url>/article/nuxt-huan-jing-da-jian/</url>
      
        <content type="html"><![CDATA[<h1><span id="nuxt-环境搭建">Nuxt 环境搭建</span></h1><h3><span id="一-通过-vue-安装-nuxt-项目">一、通过 vue 安装 Nuxt 项目</span></h3><ol><li><p>安装 vue 环境</p><pre class=" language-language-sh"><code class="language-language-sh">npm install vue-cli -g</code></pre></li><li><p>使用vue安装 nuxt</p><pre class=" language-language-sh"><code class="language-language-sh">vue init nuxt/starter</code></pre></li><li><p>使用npm install安装依赖包</p><pre class=" language-language-sh"><code class="language-language-sh">npm install</code></pre><p>出现如下图所示：（安装成功）</p><img src="https://img.nbjike.com/jietu/20200414005416.png" style="zoom:50%;"></li><li><p>使用npm run dev 启动服务</p><pre class=" language-language-sh"><code class="language-language-sh">npm run dev</code></pre><p>出现如下图所示：启动成功</p><img src="https://img.nbjike.com/jietu/20200414011243.png" style="zoom:50%;"></li></ol><h3><span id="二-通过-nuxt-脚手架安装">二、通过 Nuxt 脚手架安装</span></h3><p>安装 Nuxt 脚手架</p><pre class=" language-language-sh"><code class="language-language-sh">npm i create-nuxt-app -gcreate-nuxt-app my-nuxt-democd my-nuxt-demonpm run dev</code></pre><p>出现如下图所示：启动成功</p><img src="https://img.nbjike.com/jietu/20200414011243.png" style="zoom:50%;">]]></content>
      
      
      
        <tags>
            
            <tag> Nuxt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Neo4j学习（一）基本语法</title>
      <link href="/article/neo4j-xue-xi-yi-ji-ben-yu-fa/"/>
      <url>/article/neo4j-xue-xi-yi-ji-ben-yu-fa/</url>
      
        <content type="html"><![CDATA[<h1><span id="neo4j学习一基本语法">Neo4j学习（一）基本语法</span></h1><ol><li><p>创建一个节点</p><pre class=" language-language-neo4j"><code class="language-language-neo4j">create(a:Person {sex:"男",age:19})a：是节点Person：是标签create(a:Person:Teacher {sex:"男",age:19})一个几点可以有多个标签修饰</code></pre></li><li><p>查询结果</p><pre class=" language-language-neo4j"><code class="language-language-neo4j">查询整个对象match(a:Person) return a查询对象中某个值match(a:Person) return a.sex查找所有节点match(a) return *</code></pre><p>注：match 和 return 要一起使用</p></li><li><p>创建关系</p><pre class=" language-language-neo4j"><code class="language-language-neo4j">CREATE (节点1名:节点1标签)-[关系名:关系标签]->(节点2名:节点2标签)关系：从1节点 指向 2节点</code></pre></li><li><p>where 条件</p><pre class=" language-language-neo4j"><code class="language-language-neo4j">match(e) where e.name = "wuzhuo" or e.name = "wuzhuo2" return e</code></pre></li><li><p>删除</p><pre class=" language-language-neo4j"><code class="language-language-neo4j">删除一个节点：match (x:Employee) delete x注：删除节点时，节点必须没有关系指向（否则报错）删除节点中一个属性、关系、标签：match (t:Teacher1) remove t.age return tNeo4j CQL DELETE和REMOVE命令之间的主要区别:DELETE 操作用于删除节点和关联关系。REMOVE 操作用于删除标签和属性。</code></pre></li><li><p>设置属性</p><pre class=" language-language-neo4j"><code class="language-language-neo4j">match(a:Person) set a.hight=15 return a</code></pre></li><li><p>排序</p><pre class=" language-language-neo4j"><code class="language-language-neo4j">match(t:Teacher1) return t order by t.id desc</code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Neo4j </tag>
            
            <tag> 图数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>职场中的交流和沟通</title>
      <link href="/article/zhi-chang-zhong-de-jiao-liu-he-gou-tong/"/>
      <url>/article/zhi-chang-zhong-de-jiao-liu-he-gou-tong/</url>
      
        <content type="html"><![CDATA[<h2><span id="职场中的交流和沟通">职场中的交流和沟通</span></h2><p><img src="https://img.nbjike.com/jietu/20200401003809.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> 工作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud学习2.0笔记(二) cloud 技术升级</title>
      <link href="/article/springcloud-xue-xi-2.0-bi-ji-er-cloud-ji-zhu-sheng-ji/"/>
      <url>/article/springcloud-xue-xi-2.0-bi-ji-er-cloud-ji-zhu-sheng-ji/</url>
      
        <content type="html"><![CDATA[<h1><span id="springcloud学习20笔记二-cloud-技术升级">SpringCloud学习2.0笔记(二) cloud 技术升级</span></h1><h3><span id="cloud-技术升级可替代的技术方案">cloud 技术升级（可替代的技术方案）：</span></h3><p><img src="https://img.nbjike.com/jietu/20200329151752.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> 语言 </tag>
            
            <tag> SpringCloud2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud学习2.0笔记(二) 父工程Project空间新建</title>
      <link href="/article/springcloud-xue-xi-2.0-bi-ji-er-fu-gong-cheng-project-kong-jian-xin-jian/"/>
      <url>/article/springcloud-xue-xi-2.0-bi-ji-er-fu-gong-cheng-project-kong-jian-xin-jian/</url>
      
        <content type="html"><![CDATA[<h1><span id="springcloud学习20笔记二-父工程project空间新建">SpringCloud学习2.0笔记(二) 父工程Project空间新建</span></h1>]]></content>
      
      
      
        <tags>
            
            <tag> 语言 </tag>
            
            <tag> SpringCloud2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud学习2.0笔记(一) 版本选择</title>
      <link href="/article/springcloud-xue-xi-2.0-bi-ji-yi-ban-ben-xuan-ze/"/>
      <url>/article/springcloud-xue-xi-2.0-bi-ji-yi-ban-ben-xuan-ze/</url>
      
        <content type="html"><![CDATA[<h1><span id="springcloud学习20笔记一-版本选择">SpringCloud学习2.0笔记(一) 版本选择</span></h1><ol><li><p>版本的选择</p><p>springboot 新版本以数字递增</p><p>springcloud 新版本以英国伦敦地铁站名称（首字母递增）</p><table><thead><tr><th style="text-align:center">spring boot 版本</th><th style="text-align:center">spring cloud 版本</th></tr></thead><tbody><tr><td style="text-align:center">2.x</td><td style="text-align:center">H</td></tr></tbody></table><blockquote><p>具体版本对应地址https://start.spring.io/actuator/info</p></blockquote></li><li><p>2.x 版本常用的组件pom</p><pre class=" language-language-xml"><code class="language-language-xml"><!--spring-boot 2.2.2 RELEASE--><dependency>  <groupid>org.springframework.boot</groupid>  <artifactid>spring-boot-starter-parent</artifactid>  <version>2.2.2.RELEASE</version>  <type>pom</type>  <scope>import</scope></dependency><!--spring-cloud Hoxton.SR1--><dependency>  <groupid>org.springframework.cloud</groupid>  <artifactid>spring-cloud-dependencies</artifactid>  <version>Hoxton.SR1</version>  <type>pom</type>  <scope>import</scope></dependency><!--spring-cloud-alibaba 2.1.0.RELEASE--><dependency>  <groupid>com.alibaba.cloud</groupid>  <artifactid>spring-cloud-alibaba-dependencies</artifactid>  <version>2.1.0.RELEASE</version>  <type>pom</type>  <scope>import</scope></dependency></code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 语言 </tag>
            
            <tag> SpringCloud2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jdk 源码学习环境搭建（idea）</title>
      <link href="/article/jdk-yuan-ma-xue-xi-huan-jing-da-jian-idea/"/>
      <url>/article/jdk-yuan-ma-xue-xi-huan-jing-da-jian-idea/</url>
      
        <content type="html"><![CDATA[<h1><span id="jdk-源码学习环境搭建idea">Jdk 源码学习环境搭建（idea）</span></h1><ol><li><p>新建java项目</p><p><img src="https://img.nbjike.com/jietu/20200327005516.png" alt></p></li><li><p>创建两个目录</p><p><img src="https://img.nbjike.com/jietu/20200327010115.png" alt></p></li><li><p>解压jdk自带源码zip</p><p><img src="https://img.nbjike.com/jietu/20200327010142.png" alt></p></li></ol><ol start="4"><li><p>找到对应的jdk安装目录</p><p><img src="https://img.nbjike.com/jietu/20200327010433.png" alt></p></li><li><p>进入安装目录解压 src.zip</p></li><li><p>拷贝解压后的 src 中文件夹到工程中 source 目录下</p></li><li><p>修改debug，调试可以进入源码</p><p><img src="https://img.nbjike.com/jietu/20200328235431.png" alt></p></li><li><p>修改对应源码路径</p><p><img src="https://img.nbjike.com/jietu/20200329002102.png" alt></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 环境 </tag>
            
            <tag> jdk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 入门（一）</title>
      <link href="/article/git-ru-men-yi/"/>
      <url>/article/git-ru-men-yi/</url>
      
        <content type="html"><![CDATA[<h1><span id="git-入门一">Git 入门（一）</span></h1><h2><span id="1git-安装与初始化">1.git 安装与初始化</span></h2><blockquote><p><a href="https://www.jianshu.com/p/7edb6b838a2e" target="_blank" rel="noopener">https://www.jianshu.com/p/7edb6b838a2e</a></p></blockquote><h2><span id="2git-相关命令">2.git 相关命令</span></h2><h3><span id="21-git-clone-命令">2.1 git clone 命令</span></h3><p>git clone 命令可以将远程仓库的代码克隆到本地，并在本地生成一个代码仓库版本库。ps：本地版本库中有一个隐藏的 .git 文件，版本控制都依赖于它</p><pre><code>例如：git clone https://git.dev.tencent.com/zl3450341/BossCard.git</code></pre><p>详细命令可参考：</p><blockquote><p><a href="https://blog.csdn.net/techbirds_bao/article/details/9179853" target="_blank" rel="noopener">https://blog.csdn.net/techbirds_bao/article/details/9179853</a></p></blockquote><h3><span id="22-git-status-命令">2.2 git status 命令</span></h3><p>git status 命令可以查询，本地代码仓库中是否存在**修改，**每次使用这个命令你就可以查看那些文件被修改了。</p><p>命令的详细介绍，有时间的同学可以看这里：</p><blockquote><p><a href="https://blog.csdn.net/qq_39783244/article/details/80592282" target="_blank" rel="noopener">https://blog.csdn.net/qq_39783244/article/details/80592282</a></p></blockquote><p>ps: git status 可以缩写成 git st</p><h3><span id="23-git-diff-命令">2.3 git diff 命令</span></h3><p>git diff [文件名] 命令可以查看该文件本修改了那些地方，— 代表代码被删除的地方，+++ 代表代码添加的地方</p><p>命令的详细介绍：</p><blockquote><p><a href="https://www.jianshu.com/p/80542dc3164e" target="_blank" rel="noopener">https://www.jianshu.com/p/80542dc3164e</a></p></blockquote><p>常用的指令：</p><p>git diff ：意义，查看文件在工作目录与暂存区的差别。如果还没 add 进暂存区，则查看文件自身修改前后的差别。也可查看和另一分支的区别。</p><p>git diff --cached ：意义，表示查看已经 add 进暂存区但是尚未 commit 的内容同最新一次 commit 时的内容的差异。 也可以指定仓库版本；</p><h3><span id="24-git-add-命令">2.4 git add 命令</span></h3><p>git add &lt;文件名&gt; 命令是将修改的文件添加到暂存区中。</p><p>git add . 会把当前目录中所有有改动的文件**（不包括.gitignore中要忽略的文件）**都添加到git缓冲区以待提交</p><p>git add * 会把当前目录中所有有改动的文件**（包括.gitignore中要忽略的文件）**都添加到git缓冲区以待提交</p><p>所以在有要忽略的文件（如：配置文件之类的）有做修改的时候</p><p>git add .可以正常工作，会把所有非忽略的所有有改动的文件添加到缓冲区</p><p>git add *则会报错，且此几命令不会添加任何文件到缓冲区</p><p>可以参考：</p><blockquote><p><a href="https://z724130632.iteye.com/blog/2387009" target="_blank" rel="noopener">https://z724130632.iteye.com/blog/2387009</a></p></blockquote><h3><span id="25-git-log-命令">2.5 git log 命令</span></h3><p>该命令记录当前分支中所有提交，可以查看 git 每个版本的生成的hash码，关于根据hash码可以进行版本回退，回退命令可以查看：<strong>git reset</strong> 和 <strong>git revert</strong></p><p>如果有时间“有耐心”你可以看看：</p><blockquote><p><a href="https://www.cnblogs.com/bellkosmos/p/5923439.html" target="_blank" rel="noopener">https://www.cnblogs.com/bellkosmos/p/5923439.html</a></p></blockquote><h3><span id="26-git-reflog-命令">2.6 git reflog 命令</span></h3><p>该命令记录，该版本仓库中一些命令操作，比如分支切换，clone 仓库，版本回退一些信息</p><h3><span id="27-git-fetch-命令">2.7 git fetch 命令</span></h3><p>远程主机的版本库有了更新，需要将这些更新取回本地，这时就要用到git fetch命令。</p><pre><code>$ git fetch &lt;远程主机名&gt;</code></pre><p>上面命令将某个远程主机的更新，全部取回本地。</p><p>git fetch命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。</p><p>默认情况下，git fetch取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。</p><pre><code>git fetch &lt;远程主机名&gt; &lt;分支名&gt;</code></pre><p>比如，取回origin主机的master分支。</p><pre><code>git fetch origin master</code></pre><p>所取回的更新，在本地主机上要用"远程主机名/分支名"的形式读取。比如origin主机的master，就要用origin/master读取。</p><h3><span id="28-git-branch-命令">2.8 git branch 命令</span></h3><p>git branch 来查看我们的git仓库有几个分支</p><p>git branch -a 可以查看git 远程仓库所有分支</p><p>git branch [分支名] 新建一个分支</p><p>详细介绍可以参考</p><blockquote><p><a href="https://www.yiibai.com/git/git_branch.html" target="_blank" rel="noopener">https://www.yiibai.com/git/git_branch.html</a></p></blockquote><h3><span id="29-git-commit-命令">2.9 git commit 命令</span></h3><p>该命令可以用来将暂存区中的代码提交到本地仓库中</p><p>git commit 会提示缺少提示信息，必须添加参数 -m 和描述信息</p><p>git commit -am 可以将工作区中的代码添加，暂存区并存到本地仓库中</p><p>详细介绍可以参考：</p><blockquote><p><a href="https://www.cnblogs.com/qianqiannian/p/6005628.html" target="_blank" rel="noopener">https://www.cnblogs.com/qianqiannian/p/6005628.html</a></p></blockquote><h3><span id="201-git-reset-命令">2.0.1 git reset 命令</span></h3><p>该命令会将 commit 到本地仓库中的文件，回退到工作区中 也可以将暂存区中文件恢复回退到暂存区中。</p><p>git reset HEAD &lt;文件名&gt;</p><p>git reset --soft HEAD^ 将版本回退到上一个版本，不影响工作区和暂存区中的数据</p><p>git reset --hard HEAD^ 将版本回退到上一个版本，工作区和暂存区中的数据会丢失</p><p>git reset --mixed HEAD^ 将版本回退到上一个版本，恢复暂存区中的数据被恢复至工作区中 该命令同等与      git reset HEAD^</p><p>详细介绍可见：</p><blockquote><p><a href="https://www.cnblogs.com/fireworld/p/8961760.html" target="_blank" rel="noopener">https://www.cnblogs.com/fireworld/p/8961760.html</a></p></blockquote><h3><span id="202-git-revert-命令">2.0.2 git revert 命令</span></h3><p>git revert 撤销 某次操作，此次操作之前和之后的commit和history都会保留，并且把这次撤销</p><p>作为一次最新的提交</p><p>git revert HEAD          撤销前一次 commit</p><p>git revert HEAD^        撤销前前一次 commit</p><p>git revert commit （比如：fa042ce57ebbe5bb9c8db709f719cec2c58ee7ff）撤销指定的版本，撤销也会作为一次提交进行保存。</p><p>git revert是提交一个新的版本，将需要revert的版本的内容再反向修改回去，</p><p>版本会递增，不影响之前提交的内容</p><p>reset 和 revert 的区别可以看这里：</p><blockquote><p><a href="https://juejin.im/post/5b0e5adc6fb9a009d82e4f20" target="_blank" rel="noopener">https://juejin.im/post/5b0e5adc6fb9a009d82e4f20</a></p></blockquote><p>2.0.3 git checkout 命令</p><p>git checkout [文件名]，撤销在<strong>工作区</strong>中的修改，还未提交到<strong>暂存区</strong>的情况。</p><p>git checkout [分支名]，切换分支</p><p>git checkout -b [分支名]，以当前分支为基础创建一个新的分支，并切换到新的分支上</p><p>详细命令可看：</p><blockquote><p><a href="https://blog.csdn.net/longintchar/article/details/82953474" target="_blank" rel="noopener">https://blog.csdn.net/longintchar/article/details/82953474</a></p></blockquote><h3><span id="204-git-rm-命令">2.0.4 git rm 命令</span></h3><p>git rm 是将文件删除后，自动添加到暂存区中</p><p>rm 文件，是将文件删除，不会添加到暂存区</p><p>git rm file: 从staging区移除文件,同时也移除出工作目录.</p><p>git rm --cached: 从staging区移除文件,但留在工作目录中</p><p>命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</p><h3><span id="205-git-remote-命令">2.0.5 git remote 命令</span></h3><p>为了便于管理，Git要求每个远程主机都必须指定一个主机名。git remote命令就用于管理主机名。</p><p>不带选项的时候，git remote命令列出所有远程主机。</p><h3><span id="206-git-pull-命令">2.0.6 git pull 命令</span></h3><p>git pull 命令其实相当于git fetch 和 git merge</p><p>git pull命令用于从另一个存储库或本地分支获取并集成(整合)。git pull命令的作用是：取回远程主机某个分支的更新，再与本地的指定分支合并</p><p>详细命令可参考：</p><blockquote><p><a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/06/git_remote.html</a></p></blockquote><h3><span id="207-git-push-命令">2.0.7 git push 命令</span></h3><p>命令用于将本地分支的更新，推送到远程主机。</p><p>git push origin branchName : 把当前分支merge到远程分支branchName</p><p>详细命令可参考：</p><blockquote><p><a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/06/git_remote.html</a></p></blockquote><h3><span id="208-git-merge-命令">2.0.8 git merge 命令</span></h3><p>合并当前分支和其他分支:</p><p>git merge &lt;其他分支名&gt;, 若两个分支之间存在冲突,必须手动解决冲突后再提交</p><p>远程合并分支</p><p>git fetch &lt;远程仓库名&gt;</p><p>git merge &lt;远程仓库名&gt;/&lt;远程分支名&gt;</p><p>执行上面两步,先必须通过git remote add &lt;远程仓库名&gt; &lt;此仓库在github上的URL&gt;与远程仓库关联,然后再fetch和merge,解决冲突与本地一样</p><p>git merge --abort 抛弃当前合并</p><p>git merge 详细命令可以参考</p><blockquote><p><a href="https://www.jianshu.com/p/58a166f24c81" target="_blank" rel="noopener">https://www.jianshu.com/p/58a166f24c81</a></p></blockquote><p>merge冲突时二选一</p><blockquote><p><a href="https://blog.csdn.net/qinjienj/article/details/7816047" target="_blank" rel="noopener">https://blog.csdn.net/qinjienj/article/details/7816047</a></p></blockquote><h3><span id="209-git-stash-push-和-git-stash-pop">2.0.9 git stash push 和 git stash pop</span></h3><p>当你在一个分支上编写代码时，还没提交。但是又想切换到新的分支上去。如果你切换分支是允许的。你需要将工作区或者暂存区中的操作git stash push 压入一个栈中，这样就可以切换到别的分支上去了。当其他分支操作完毕，可以切回当前分支：使用git stash pop 恢复原先的操作</p><p>详细命令可以参考：</p><blockquote><p><a href="https://git-scm.com/book/zh/v1/Git-%E5%B7%A5%E5%85%B7-%E5%82%A8%E8%97%8F%EF%BC%88Stashing%EF%BC%89" target="_blank" rel="noopener">https://git-scm.com/book/zh/v1/Git-%E5%B7%A5%E5%85%B7-%E5%82%A8%E8%97%8F%EF%BC%88Stashing%EF%BC%89</a></p></blockquote><h2><span id="如果还是不会怎么办">如果还是不会怎么办？</span></h2><p><strong>git --help</strong> 可以查看常用的命令</p><p><strong>git help</strong>**「相关命令」**可以查看具体命令的操作</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信生态中细致运营的一百条小技巧</title>
      <link href="/article/wei-xin-sheng-tai-zhong-xi-zhi-yun-ying-de-yi-bai-tiao-xiao-ji-qiao/"/>
      <url>/article/wei-xin-sheng-tai-zhong-xi-zhi-yun-ying-de-yi-bai-tiao-xiao-ji-qiao/</url>
      
        <content type="html"><![CDATA[<h1><span id="微信生态中细致运营的一百条小技巧">微信生态中细致运营的一百条小技巧</span></h1><p><strong>杨涛</strong> 在知识星球【<a href="https://github.com/lijiaocn/oper/blob/master/README.md" target="_blank" rel="noopener">生财有术</a>】 中做的分享，本站进行了精校和高亮处理。</p><p>今天是认识亦仁一周年的大日子，写点东西，顺序分类什么的就不顾了啊，想到什么写什么，估计得写一万字吧，文笔不好，大佬们慢慢看哈，应该有那么几十条能get到你。</p><p>说在前头的话，在座是一亿假互联网人，我们宗旨是要为十三亿真互联网人服务，so，小号中的，普适性的普渡技。</p><h2><span id="一百条小技巧">一百条小技巧</span></h2><p>★★★，自己和团队抽个时间，手机放一边，拿张纸，自己默写微信的功能，浅入深，看看能不能拼凑出一百个功能，这个行为非常有帮助。</p><p>★★★，各种功能还自带大流量哦，举个小例子，点击–发现，点击–游戏，进入，底下一排第二个，游戏圈，进去看看，惊不惊喜，意不意外，画像一致的，去畅享千万曝光吧。</p><p>★★★，其实权重什么的，真是说不准，乡下号，爱怎么搞怎么搞，某些高危园区的，就算是真人，在严打的时候也一样会限制，简单理解是特征吧，某些软件，就好比在公安局备案过的嫖客，每次抓就先抓带这种特征的。</p><p>★★★，辅助工具的话wetool，爆汁，微精灵，微易发，问财神咯，就不指定推荐了，都挺好用，看个人。</p><p>★★★，被删除的好友重新加上不会被发现，删除对方后，只要你记得对方的微信号，直接重新加他好友就可以了。前提是对方没有将你删除，如果对方也删除了你肯定需要验证的。</p><p>★★★，除了配合工具测僵尸知道自己是不是被删被拉黑了，单点突破或者小范围，也可以优雅滴知道，比如可以转0.1元给他，会提示不能转，也可以拉群，30人以下群是不被提醒的。</p><p>★★★，微信号是可以不绑手机卡哒，手机号不可以解绑，只能用换绑来解除绑定。微信换绑，需要准备Q号年龄在一年以上的，或者把设置微信号登陆。新的手机号貌似无限注册微信，（一个月只能注册一次）</p><p>★★★，简单模拟真人行为的，加群互动，发红包，转账，跟老号语音或视频，3分钟以上。</p><p>★★★，可以使用通讯录导入和微信id导入，wxid可以通过软件在群里批量获取，通讯录导入可以尝试用脚本跑号码段（我指跑139,130等各种老的号码段，相对精众你懂的），或者通过各种裂变手段收集的手机号来。</p><p>★★★，点赞和朋友圈留言是一种提高粘性和存在感的行为，如果要出来卖，请抛弃那点点精神洁癖，秒变点赞狂魔也不是不可以，如果是营销号，记得天天刷存在哦。</p><p>★★★，微信运动的封面是一个很好的广告位，我的小号每天都第一，就用那个摇摆机没毛病，除了曝光，特么每月还有七八杯星巴克免费之类的，羊毛薅一堆，还是那句话，别替你的受众去思考，也许他们就喜欢每天点开看排行。</p><p>★★★，加好友的话术极其重要。1、决定了通过率；2、决定通过之后的留存和信任度转化率。不同的群是可以用不同的话术的，付费群的话比如，我是来自生财有术的杨涛，至今好像都通过了，其他各种啥老同学，你好，朋友推荐的，有事找你，来自名片分享，交个朋友，我换微信号啦等，挺多的，都不错，看人群。ps，今天李神还给我发了两条验证，一条是ems头像，你的快递在小区门口，我给你放鸟箱了，一条是，我是你楼下的住户，你的卫生间是不是漏水?</p><p>★★★，多号运作，所有微信号必须有Excel来分类并且手机背后要贴备忘标签的。</p><p>★★★，进群看群规，改群昵称是比想象中重要的，群昵称是最好的广告，且是蹭热点，刷存在的利器，举例，我可以在某个群改昵称为亦仁的表哥，或者改成日加五千粉-杨涛，会get到一些眼球。之前还试过几个有意思的，比如_@,这样人家@你就变成了@_@，比如，你已被群主亦仁踢出本群，然后就被群嘲了等等。</p><p>★★★，关于人设多说两句，人设人设人设！ 一个优雅真实的朋友圈是可以这样的，大号里的好友朋友圈有特别突出的，不管哪方面，然后你用大号转发她的朋友圈图片和文字给你的小号，这样你的小号就是一个真实而优雅的真人，当然你要去淘宝买也可以，但是用的人多了。</p><p>★★★，在微信中，人和人之间的沟通应该是纯文字的，且必须是纯文字的，任何一个语音应该是不会去听的，所以，我用讯飞，识别率确实高，另外，善用自带的标签快捷回复功能，我的客服自带一百条以上的快捷回复。</p><p>★★★，wetool等工具最核心功能是公号裂变工具，牛逼在于群功能，结果被用成了爆粉工具。</p><p>★★★，“马住”用来备忘非常好用，这条重点说下，群聊中有某些干货，你就直接往这条干货底下打一个“马住”，然后每个月底，直接搜索“马住”，然后把所有“马住”的内容都复制出来另存，这个就是你这个月的隐性收获了。另一个就是公司小群布置任务，有时候就是不钉钉，就布置完任务然后输入一个“马住”代表对这个事情的重视，这个知识点的重要，等场景。—其实我说的就是mark的意思，“马住”是为了表达对马老师的仰慕倾慕，同时也是一个差异化的词，确保搜出来都是你在意的内容。</p><p>★★★，装逼的学名叫做自我实现，是马斯洛需求层次的顶层需求，希望做产品做传播要赋予它这个属性。zhuangbility lead niubility。</p><p>★★★，每当你老婆要和你合影发圈的时候，记得深情目光看向她，别看镜头，这样当她发完圈，闺蜜的赞叹会让她的虚荣心得到极大的满足。</p><p>★★★，忘记什么日主动只能加多少人，被动最多能加多少人诸如此类的，看号的权重的。</p><p>★★★，一证十五卡一机一卡一号，能用流量尽量用流量，费用各地不同吧，我是电信宽带免话费五张，移动月租19块，联通月租18块，我们这旮旯好像没有免月租的。</p><p>★★★，取消验证，有验证的七十二小时就失效的，取消验证之后，可以突破一些加好友的上限，一点点。</p><p>★★★，请关注多几个伟大的卖货号，文案带货确实是值得一学。</p><p>★★★，人设，也就是昵称，头像，朋友圈比你想像的重要得多。</p><p>★★★，你的粉想看什么你就展示什么给她，其实你不知道他们都有关注你的，不信你发个送东西的，保准一堆人找你要。</p><p>★★★，书是买来摆设的，课是买来不听的，9成人适用，扪心自问吧亲们，此处应有bgm，易（良）灵（心）微课了解一下。tx</p><p>★★★，群是很容易获得的，尤其是辅食，童装，拼团，国学，中医，读书会等，这些泛群是有价值的，你拿出圆来画，她们都符合某几个特征。举一反三，贯彻到所有的号上。</p><p>★★★，如果要玩多号，玩群，请时刻告诉自己，你是个美女。</p><p>★★★，想要卖课的，最好可以多加一些付费群，越贵越好，为啥呢，相信我，付费有瘾，你如是，他们亦然。</p><p>★★★，某种意义上来说，获取粉丝成本是不超过三毛一个才达标的，有点拗口，粉不可以骗，他的钱可以骗。</p><p>★★★，王六六的裂变增长群可以了解一下。</p><p>★★★，其实是可以和你的朋友们一起共建一个巨大的流量池，核心词，共建共享，等体量交换。</p><p>★★★，截流可以是一个有效的行为，小心小心，他们好烦。</p><p>★★★，群聊天记录中搜索关键词是可以打开新世界的。</p><p>★★★，微信是有seo的。</p><p>★★★，好文案是大于好产品的！的！的！的！</p><p>★★★，不管什么场景，让用户先付费，然后把这个流量导来导去转一圈，然后再跳出APP下载链接，不下就听不了课享受不了服务啊，流氓些，但是挺好。</p><p>★★★，请善用H5！</p><p>★★★，最底层的信息是手机号码，给自己的反复触达留一扇门。</p><p>★★★，视频透出可以选择在前三秒后三秒带图带信息，30秒后淡入二维码留存几率大。</p><p>★★★，部分行业和类目，海报或者视频或者问答等各种透出，要留微信号的别怕路径长，别纠结二维码和留微信号的区别，这个本身是一种清洗，愿意打开手机，点开微信，选择添加朋友，然后再输入你手机号的，本身就是精准的一种表现模式。</p><p>★★★，一个好的视频封面可以大上限的提高打开率。</p><p>★★★，尽可能让同一波流量在你的各种不同载体里头转一圈，公众号，个人号，群，知识星球，小程序之类的。</p><p>★★★，在群里发广告永远选择群三十分钟左右没发言的时候，这样曝光几率最大化。</p><p>★★★，如果想建活跃群，托和话题很重要，30人是一个分界线，30人以内的小群大概率可以活跃并存活的比较久。</p><p>★★★，改昵称和发自我介绍是一种仪式感，每个人在群里的每一次发言，被每一次@，以及在这个群里加的每一个好友，其实增加的是他自己本身对这个群的认同和彼此的凝聚力。</p><p>★★★，广告群的价值体现在你会不会做信息分析。</p><p>★★★，一个微信一天进群直到频繁，三四个小时后可以再试一次，再频繁之后第二天再进，链接并没有失效。</p><p>★★★，进群链接七天失效，常见大号拉小号，小号频繁，以及买群与换群的行为中。</p><p>★★★，共同好友辅助解封，要互为好友七天以上，家中常备解封号。</p><p>★★★，充分利用朋友圈提高曝光，这不，再小的个体也有自己的声音，单号理论展现几千次，cpm0，哪儿去找？</p><p>★★★，某些场合，比如客单高的产品，沙龙或者高端群的吸粉，微信通过人的时候，一次通过三四个，及时回复与跟进可以提高粘性和转化，比及时通过更重要。</p><p>★★★，活跃的同行群，是可以看项目，你所在的类目有什么新产品，新模式你没有发现。</p><p>★★★，活跃的群，还可以看话术，同行的海报和广告话术积累下来都是很宝贵的素材。</p><p>★★★，在活跃的群里，还可以获取更多新群，群里同行会发出来二维码加群，也可以扮素人，加活跃的同行，问她要，被揭穿后，可以换，可以买。</p><p>★★★，流量本身也是没有属性的，最终会流量会流向能用它创造出最高价值的人手上。只要是流量，都有用。所以流量没有好坏优劣之说，比如A10的亦仁是好对吧，但是你一个买壮阳药的加了他，想等他给你消费，估计得等30年。女的。活的。即是好的。</p><p>★★★，聊天中可以查找交易信息，当然同时还有文件，链接，音乐图片视频，以及按日期检索，真心好用，+1。</p><p>★★★，可以给聊天中的信息设置日期提醒，比如今天妹子约了我明天共进晚餐，我长按就是设置明天6点别忘记，到时候就会收到提醒。</p><p>★★★，可以用给赞生成自己的赞赏码等超多玩法等你研究。</p><p>★★★，聊天记录可以批量转发给多人。</p><p>★★★，群主可以了解到每个群员的加群途径，从而区分连带责任。</p><p>★★★，自己发自己仅小号可见的朋友圈可以用小号预览效果，譬如，可以尝试下不同系统朋友圈几行字内不折叠。</p><p>★★★，新进一个群，想知道群里有多少好友在，方便知道什么该说什么不该说，点击通讯录–标签–新建–从群里导入–选择群聊，即可。</p><p>★★★，查看公号热度（即有多少好友一同关注），取消关注–搜索该公众号–右边就可以知道，比方说某男同号，艾玛竟然有50个朋友关注了- -！</p><p>★★★，建单人群，拉2个好友然后再将两人删除，或者，面对面建群，连拉人都不用，直接就单人群了，妥了，顶替文件传输助手，草稿箱，闪念，避免群发尴尬，游戏续命等。</p><p>★★★，查看好友某个时间段朋友圈（搜索-朋友圈一好友-筛选）</p><p>★★★，单点屏蔽三部曲，某人消息不提醒，某人单独分组命名为朋友圈不给他看，然后每次发圈选不让谁看。觉得麻烦么？因为不能屏蔽，不能拉黑但不想交流的人还是有的。</p><p>★★★，当已点赞或者评论某条朋友圈,朋友们也在下面互动,如果不想收到大量的提醒,los用户只要将这条消息向左划然后选择不再通知就可以,安卓用户则是长按这个提醒，然后选择不再通知。</p><p>★★★，删除好友后再次添加不会提醒对方。</p><p>★★★，长按头像可在群聊里@该用户，两人聊天时候长按头像即复制对方昵称，微信pc端右键即可引用此条的聊天内容。</p><p>★★★，朋友圈长按头像可直接设置朋友圈权限，唉，这年头，路径短一些就是一些，和pc端一样，养成良好的组合键习惯，可以凭空省下很多时间。</p><p>★★★，微信发送高清照片，聊天窗口—加号长按相册按钮。</p><p>★★★，每过一个月，微信容易卡，想要微信拍照不自动保存，设置关掉自动存储的开关。设置—通用—照片和视频。</p><p>★★★，长按群视频或者，朋友圈小视频，选择静音播放，告别岛国尴尬。</p><p>★★★，做某些裂变行为的时候，可以设置为默认通过好友，这样的好处是，永久可以生效，只需要回头加他好友即可。而不是3天失效。</p><p>★★★，同样的，做某些不是那么符合价值观的裂变行为时候，可以设置为需要验证后通过，然后谨记，2天后再通过他，九成已经忘了他是为何加你的。</p><p>★★★，长按拍照按钮，然后上下滑动手指，可以调节焦距。</p><p>★★★，在手机上删除掉全部聊天记录之后，登录网页端还可以看到最后一些内容，保持电脑和手机在线这个习惯挺好的，偶尔遇到没电的情况还可以到电脑端续上聊天，而且文件的话也可以直接下载到电脑看。</p><p>★★★，把gif动图发到微信网页版,可以自动转为动画表情。</p><p>★★★，微信主页面，左右滑动可以切换不同栏目。</p><p>★★★，技巧卡包里头，朋友的优惠券，经常有好吃的餐券和酒店券，是否可以自己弄个券分享，然后全好友可见呢？呵呵呵。</p><p>★★★，绑定QQ后，在朋友圈发布后，可以同步到QQ空间，营销的同学记一下，珍而重之，春光灿烂的战场在QQ。</p><p>★★★，可以提醒谁看@最多10个好友哦。</p><p>★★★，长按相机键不放开即可发布纯文字朋友圈。</p><p>★★★，发朋友圈的时候，有个所在位置，可以自定义编辑，装逼神器，比如我可以发一张手持红酒杯，定位输入生财有术总部，倍儿有面子。</p><p>★★★，我们都有大量的微信群，有些碍于面子不好退，时不时就999+，选择我-设置-通用-清理微信储存空间-查看-选择对应的好友或群清除即可。</p><p>★★★，有时候很多好友给你朋友圈留言了，或者你去你的朋友的朋友圈留言了，然后去忙其他事情了，过后想去撕逼或者当吃瓜群众，另外比如做活动做裂变的时候，在我的相册右上角就可以查看所有给你留言互动的内容啦。</p><p>★★★，长按朋友圈右上角拍照图标就可以发纯文字的朋友圈啦。</p><p>★★★，微信聊天记录导出备份必须养成习惯，虽然你是如此的严谨，但是每过阵子总会听到朋友说艾玛聊天记录没了，好难过。</p><p>★★★，搜一搜里头有搜索表情，有时候此情此景一定要某个表情才能完美切入，哈哈，嗯，确保斗图无忧，当然，涛哥表情图全套了解一下。</p><p>★★★，删除好友后聊天记录就没有啦，加回来也没有啦，搜不到啦，但是拉黑加回来，聊天记录还在。</p><p>★★★，安卓长按相册就会跳转到相机，自带美颜哦。</p><p>★★★，微信相机打开后，双击是可以切换镜头的哦。</p><p>★★★，微信钱包里头，支付管理，转账到账时间是可以设置即时到账，2小时，和24小时的哦。</p><p>★★★，辅助注册+辅助解封，1次/月，2次/半年，3次/年，先把自己的大号小号拉到一起，彼此互加咯。</p><p>★★★，个人认为要是某个项目做个一年，客户关系管理上，沉淀10个左右的满人个人号，要是再有几十个活跃的微信群，就是很棒的一年。</p><p>★★★，冷启是最难了，那能每次大辉哥哥，曹叔叔头条给你冷启对吧，所以我们假设大辉哥哥的冷启指数是200，曹叔叔的冷启指数是200，那么我们均300人群的冷启指数是0.5/单群，也划算啊，也牛逼啊，据我所知，手握10万群应该是不大难，具体可以参考当年淘客们，另外之前有个姓唐的风骚少年好像也是短时间做到了近2w群。</p><p>★★★，这不，全民小号热潮，想知道你买的小号是几几年注册的么，点开钱包—&gt;右上角—&gt;账单—&gt;年份—&gt;往回翻，你就会发现最早的一个月是几几年几月啦，如果没有绑卡没有实名认证的，也没有关系，一样从这个路径进入，账单是按注册时间出现的，哪怕没有使用过这个功能。</p><p>★★★，像我这种偶尔要客串七八个客服微信的男子怎么办，如何在电脑端打开多个微信呢，很简单，鼠标单击桌面微信快捷方式图标，然后用单身28年的手速疯狂按下回车键，按几下就可以出现多少个微信登陆框，然后挨个登陆就好了，哦对了，我的记录是21个。</p><p>★★★，裂变的时候您会经常发现分享到朋友圈加好友就给价值多少的PPT模板或者裂变海报五万张或者给价值多少的小猪佩奇500集高清视频，但最后给的都是个云盘地址，那我就聪明了，我把这些下载下来，然后打开，确认没有别人的联系方式，然后多加了很多料，然后打上我的联系方式，然后重新到云盘，这样，然后发到运营群，同行群里头，这样很多人就会加我啦，获取了，然后转存下，看也不看的用在他们的裂变素材中，嘿嘿嘿。</p><p>★★★，做推广的时候想主推一个微信，会存在推二维码，推手机同号，推微信号等几种情况，那么又会出现几种情况，部分平台推二维码是拒绝的，手机号是拒绝的，微信号的意义就出来了，取一个很好记的微信号字母+数字还是可以做到五个字符内解决的，这样起码过了机器识别这关，快去试试吧。</p><p>★★★，如何一次推广长期受用，打开微信，点开我，点开隐私，点开添加我的方式，有没有发现第三个是QQ，很好，不论是群推海报，还是SEO等其他方式，有时候一次成功的推广，这个号就被加满了，那么如果我们推广的是QQ号，那就可以很愉快的解绑换绑到一个新的微信号上，这样客户就又可以通过这个QQ号加上你的新微信啦。解绑换绑QQ在账号与安全，更多安全设置，点击QQ，再点击右上角就可以啦。</p><p>★★★，天气不错我来家旁边的SM喝咖啡，SM呢是厦门最标志性的商场，比万达高一级，一路走来看到了超过五个小蓝杯的广告，确实是强植入了我脑海，我就想啊，在同等文案和诱惑的情况下，九成的本地新店投放是声势浩大的一波，然后泯然众人，从ROI角度来说，比如我在厦门开了家泡椒田鸡或者婚纱摄影，那么要做推广的时候就绝不会是一波流，我会投放厦门厦门，大城小事，厦门生活等本地号，然后本地群，本地朋友圈投放隔三天一波连续一个月，然后到店转发也是持续持续，这样就能生造出一个很热门的店铺。</p><p>★★★，又联想，我就随便举一个例子，比方说我拿10个号同时加入一个付费的群，有点小高端，然后争取加上这些群友，那么比如今天想做一个小贵的网课推广，那么我就用这十个号按时段发这个网课的码，对于这个群里的人来说就等于，你有10个好友从早上八点到晚上八点都在你的朋友圈发这个网课，而你看到你的好友都买了都推了，同时又对你貌似又有用，你基本上就会买了，不会有太多的思考，最起码，你在你朋友圈里看到连续十个人说有个大佬叫亦仁，哪怕你不认识，起码也认识了，会去搜一搜吧，这是一个很有意思的事情。同理可以在宝妈群，小区群，或者其他相对垂直画像一致的社群里适用。</p><p>★★★，我一般最常用的3个小号有拉了一个群，重要的东西比如文件啊，图片啊，往里头一丢，这是天然的云端办公哇，当然了，我还有分类^_^，比方说，牛逼的小程序要拆解的，一个群，看到眼前一亮的文章，没空细致看的，丢一个群，精华海报，一个群，等等。</p><p>天色已晚， 最后，执行是不是第一位的？ 有句话叫做， 你的勤奋不足以考验你的智商， 你的执行还没办法检验你的创意， 好，今天的鸡汤就到这里， 纯手打，累，进阶版下次再写。</p><h2><span id="评论精选">评论精选</span></h2><p>猫先生：微信如何seo？</p><p>杨涛 回复 猫先生：微信的搜索，也就是那个放大镜，越来越频繁的被使用，里头有公众号，小程序，朋友圈，文章，视频，百科，问答等老多了，都可以做优化的，相对容易，另，举例，甚至哪怕是你在某群里头埋了点，两种，比如你的某群昵称，群名字就叫做世界杯，或者你曾经在某群聊天记录里头埋点有提过你是做世界杯外围投注的，那么下一个热点世界杯来了，别人搜世界杯，就会收到：某群（包含 sonne（世界杯投注）），再下来，聊天记录，某群，10条相关，点开，就是你的名字，都会被搜索到，我这样说清楚么，您举一反三下。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 微信运营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud学习笔记(十一) Config 分布式配置中心</title>
      <link href="/article/springcloud-xue-xi-bi-ji-shi-yi-config-fen-bu-shi-pei-zhi-zhong-xin/"/>
      <url>/article/springcloud-xue-xi-bi-ji-shi-yi-config-fen-bu-shi-pei-zhi-zhong-xin/</url>
      
        <content type="html"><![CDATA[<h1><span id="springcloud学习笔记十一-config-分布式配置中心">SpringCloud学习笔记(十一) Config 分布式配置中心</span></h1><ol><li><p>在 GitHub 上创建仓库（配置文件）</p></li><li><p>克隆并添加配置文件（application.yml）ps：需要 utf-8 格式</p></li><li><p>上传到远程仓库</p></li><li><p>创建 config server 微服务</p></li><li><p>pom</p><pre class=" language-language-xml"><code class="language-language-xml"><dependency>            <groupid>org.springframework.boot</groupid>            <artifactid>spring-boot-starter-actuator</artifactid>        </dependency>        <dependency>            <groupid>org.springframework.cloud</groupid>            <artifactid>spring-cloud-config-server</artifactid>        </dependency></code></pre></li><li><p>yaml</p><pre class=" language-language-yaml"><code class="language-language-yaml">server:  port: 3344spring:  cloud:    config:      server:        git:          uri: https://github.com/flea-wu/wfw-config.git          username: 账号（如果 Github 配置了公私钥，可以省略）          password: 密码  application:    name: cloud_confg_name</code></pre></li><li><p>@EnableConfigServer</p><pre class=" language-language-java"><code class="language-language-java">@SpringBootApplication@EnableConfigServerpublic class CloudConfigStart {    public static void main(String[] args) {        SpringApplication.run(CloudConfigStart.class, args);    }}</code></pre></li><li><p>test</p><blockquote><p><a href="http://127.0.0.1:3344/application-test.yml" target="_blank" rel="noopener">http://127.0.0.1:3344/application-test.yml</a></p><p><a href="http://127.0.0.1:3344/application-dev.yml" target="_blank" rel="noopener">http://127.0.0.1:3344/application-dev.yml</a></p></blockquote></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 语言 </tag>
            
            <tag> SpringCloud </tag>
            
            <tag> Config </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud学习笔记(十) Zuul 路由网关</title>
      <link href="/article/springcloud-xue-xi-bi-ji-shi-zuul-lu-you-wang-guan/"/>
      <url>/article/springcloud-xue-xi-bi-ji-shi-zuul-lu-you-wang-guan/</url>
      
        <content type="html"><![CDATA[<h1><span id="springcloud学习笔记十-zuul-路由网关">SpringCloud学习笔记(十) Zuul 路由网关</span></h1><ol><li><p>作用</p><p>提供 =&gt; 代理 + <strong>路由</strong> + <strong>过滤</strong> 三大功能</p><p>Ps : Zuul 服务最终还是会注册进 Eureka</p></li><li><p>环境配置</p><ol><li><p>pom</p><pre class=" language-language-xml"><code class="language-language-xml"><dependencies>        <dependency>            <artifactid>api</artifactid>            <groupid>com.fleawu</groupid>            <version>1.0-SNAPSHOT</version>        </dependency>        <dependency>            <groupid>org.springframework.cloud</groupid>            <artifactid>spring-cloud-starter-netflix-eureka-client</artifactid>        </dependency>        <dependency>            <groupid>org.springframework.boot</groupid>            <artifactid>spring-boot-starter-actuator</artifactid>        </dependency>        <dependency>            <groupid>org.springframework.cloud</groupid>            <artifactid>spring-cloud-starter-netflix-zuul</artifactid>            <version>2.0.3.RELEASE</version>        </dependency>    </dependencies></code></pre></li><li><p>yml</p><pre class=" language-language-yaml"><code class="language-language-yaml">server:  port: 4001spring:  application:    name: microservicecloud-zuul-gatewayeureka:  client:    service-url:      defaultZone: http://eureka01:6001/eureka,http://eureka02:6002/eureka,http://eureka03:6003/eureka  instance:    instance-id: zuul-gateway    prefer-ip-address: true</code></pre></li><li><p>主启动类</p><pre class=" language-language-java"><code class="language-language-java">@SpringBootApplication@EnableEurekaClient@EnableZuulProxy //开启zuulpublic class ZuulStart {    public static void main(String[] args) {        SpringApplication.run(ZuulStart.class, args);    }}</code></pre></li><li><p>测试</p><p>不用路由访问微服务提供者：<a href="http://127.0.0.1:7001/buy/book" target="_blank" rel="noopener">http://127.0.0.1:7001/buy/book</a></p><p>使用路由访问微服务提供者：<a href="http://127.0.0.1:4001/provider/buy/book" target="_blank" rel="noopener">http://127.0.0.1:4001/provider/buy/book</a></p></li><li><p>修改yml</p><pre class=" language-language-yaml"><code class="language-language-yaml"># 代理名称zuul:  routes:    a.serviceId: provider    a.path: /b/**# 忽略单个的微服务名称# ignored-services: provider# 忽略所有微服务ignored-services: "*"#  统一前缀  prefix: /wu  </code></pre></li></ol></li></ol><p>@EnableZuulProxy 和 @EnableZuulServer 区别</p><p>​@EnableZuulProxy 强一点</p>]]></content>
      
      
      
        <tags>
            
            <tag> 语言 </tag>
            
            <tag> SpringCloud </tag>
            
            <tag> Zuul </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node 安装多个版本</title>
      <link href="/article/node-an-zhuang-duo-ge-ban-ben/"/>
      <url>/article/node-an-zhuang-duo-ge-ban-ben/</url>
      
        <content type="html"><![CDATA[<h1><span id="node-安装多个版本">Node 安装多个版本</span></h1><h4><span id="解决方案一n">解决方案一（n）</span></h4><h5><span id="1安装node版本管理模块n">（1）安装node版本管理模块n</span></h5><pre><code>sudo npm install n -g</code></pre><p>下边步骤请根据自己需要选择</p><h5><span id="2安装稳定版">（2）安装稳定版</span></h5><pre><code>sudo n stable</code></pre><h5><span id="3安装最新版">（3）安装最新版</span></h5><pre><code>sudo n latest</code></pre><h5><span id="4-版本降级升级">（4） 版本降级/升级</span></h5><pre><code>sudo n 版本号</code></pre><h4><span id="解决方案二参见">解决方案二（参见）</span></h4><blockquote><p><a href="https://blog.csdn.net/Fabulous1111/article/details/84983869" target="_blank" rel="noopener">https://blog.csdn.net/Fabulous1111/article/details/84983869</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud学习笔记(九) Hystrix Dashboard</title>
      <link href="/article/springcloud-xue-xi-bi-ji-jiu-hystrix-dashboard/"/>
      <url>/article/springcloud-xue-xi-bi-ji-jiu-hystrix-dashboard/</url>
      
        <content type="html"><![CDATA[<h1><span id="springcloud学习笔记九-hystrix-dashboard">SpringCloud学习笔记(九) Hystrix Dashboard</span></h1><h3><span id="hystrix-dashboard-配置">Hystrix Dashboard 配置</span></h3><ol><li><p>新建一个 Hystrix Dashboard 的微服务项目</p></li><li><p>pom</p><pre class=" language-language-xml"><code class="language-language-xml">    <dependencies>        <dependency>            <groupid>org.springframework.cloud</groupid>            <artifactid>spring-cloud-netflix-hystrix-dashboard</artifactid>        </dependency>        <dependency>            <groupid>org.springframework.boot</groupid>            <artifactid>spring-boot-starter-actuator</artifactid>        </dependency>        <dependency>            <artifactid>api</artifactid>            <groupid>com.fleawu</groupid>            <version>1.0-SNAPSHOT</version>        </dependency>    </dependencies></code></pre></li><li><p>yml</p><pre class=" language-language-yml"><code class="language-language-yml">server:  port: 9001</code></pre></li><li><p>主启动类</p><pre class=" language-language-java"><code class="language-language-java">@SpringBootApplication@EnableHystrixDashboardpublic class HystrixStart {    public static void main(String[] args) {        SpringApplication.run(HystrixStart.class, args);    }}</code></pre></li><li><p>所有微服务提供者都需要有监控依赖配置</p></li><li><p>启动 hystrix-dashboard 项目</p><p>访问：<a href="http://127.0.0.1:9001/hystrix" target="_blank" rel="noopener">http://127.0.0.1:9001/hystrix</a> ，出现如下图所示，表示环境配置成功<img src="https://img.nbjike.com/jietu/20200308215229.png" style="zoom:50%;"></p></li><li><p>启动 eureka 注册中心（集群）</p></li><li><p>启动带有 hystrix 的服务提供者</p></li><li><p>访问带有 hystrix 的服务提供者的相关服务接口</p></li><li><p>访问带有 hystrix 的服务提供者的 <a href="http://127.0.0.1:7004/hystrix.stream" target="_blank" rel="noopener">http://127.0.0.1:7004/hystrix.stream</a></p><p>若出现如图所示解决办法<img src="https://img.nbjike.com/jietu/20200308222843.png" style="zoom:50%;"></p><p>注册：HystrixMetricsStreamServlet</p><pre class=" language-language-java"><code class="language-language-java">@Bean    public ServletRegistrationBean getServlet() {        HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet();        ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet);        registrationBean.setLoadOnStartup(1);        registrationBean.addUrlMappings("/hystrix.stream");        registrationBean.setName("HystrixMetricsStreamServlet");        return registrationBean;    }</code></pre></li><li><p>打开  <a href="http://127.0.0.1:9001/hystrix" target="_blank" rel="noopener">http://127.0.0.1:9001/hystrix</a> 监测：<a href="http://127.0.0.1:7004/hystrix.stream" target="_blank" rel="noopener">http://127.0.0.1:7004/hystrix.stream</a></p><img src="https://img.nbjike.com/jietu/20200308224411.png" style="zoom:50%;"></li><li><p>最终显示如下页面</p><img src="https://img.nbjike.com/jietu/20200308224448.png" style="zoom:50%;"><p>七色、一圈、一线</p></li></ol><blockquote><p>Hystrix-dashboard是一款针对Hystrix进行实时监控的工具，通过Hystrix Dashboard我们可以在直观地看到各Hystrix Command的请求响应时间, 请求成功率等数据。但是只使用Hystrix Dashboard的话, 你只能看到单个应用内的服务信息, 这明显不够. 我们需要一个工具能让我们汇总系统内多个服务的数据并显示到Hystrix Dashboard上, 这个工具就是Turbine</p></blockquote><h3><span id="turbine"><strong>Turbine</strong></span></h3>]]></content>
      
      
      
        <tags>
            
            <tag> 语言 </tag>
            
            <tag> SpringCloud </tag>
            
            <tag> Hystrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud学习笔记(八) Hystrix 熔断、降级</title>
      <link href="/article/springcloud-xue-xi-bi-ji-ba-hystrix-rong-duan/"/>
      <url>/article/springcloud-xue-xi-bi-ji-ba-hystrix-rong-duan/</url>
      
        <content type="html"><![CDATA[<h1><span id="springcloud学习笔记八-hystrix-熔断-降级">SpringCloud学习笔记(八) Hystrix 熔断、降级</span></h1><h3><span id="hystrix-熔断概念对于服务提供者">Hystrix 熔断概念（对于服务提供者）</span></h3><blockquote><p>在微服务架构中，服务与服务之间通过远程调用的方式进行通信，一旦某个被调用的服务发生了故障，其依赖服务也会发生故障，此时就会发生故障的蔓延，最终导致系统瘫痪。Hystrix实现了断路器模式，当某个服务发生故障时，通过断路器的监控，给调用方返回一个错误响应，而不是长时间的等待，这样就不会使得调用方由于长时间得不到响应而占用线程，从而防止故障的蔓延。Hystrix具备服务降级、服务熔断、线程隔离、请求缓存、请求合并及服务监控等强大功能。</p><p>例如 Java 代码</p></blockquote><pre class=" language-language-java"><code class="language-language-java">判断是否出问题if (不出问题) {  服务消费者正常调用} else { // 出问题  走备选返回结果}</code></pre><p>使用：新建带有熔断的服务提供者</p><ol><li><p>修改 pom.xml</p><pre class=" language-language-xml"><code class="language-language-xml"><dependencies>        <dependency>            <artifactid>api</artifactid>            <groupid>com.fleawu</groupid>            <version>1.0-SNAPSHOT</version>        </dependency>        <dependency>            <groupid>org.springframework.cloud</groupid>            <artifactid>spring-cloud-starter-netflix-eureka-client</artifactid>        </dependency>        <dependency>            <groupid>org.springframework.boot</groupid>            <artifactid>spring-boot-starter-actuator</artifactid>        </dependency>  <!--熔断依赖-->        <dependency>            <groupid>org.springframework.cloud</groupid>            <artifactid>spring-cloud-starter-netflix-hystrix</artifactid>        </dependency>    </dependencies></code></pre></li><li><p>修改主启动类</p><pre class=" language-language-java"><code class="language-language-java">@SpringBootApplication@EnableEurekaClient@EnableDiscoveryClient// 开启熔断@EnableCircuitBreakerpublic class SellerStart {    public static void main(String[] args) {        SpringApplication.run(SellerStart.class, args);    }}</code></pre></li><li><p>Controller 服务添加熔断处理</p><pre class=" language-language-java"><code class="language-language-java">@RestControllerpublic class BookController {    @Resource    private BookService bookService;    @GetMapping(value = "/buy/book")    @HystrixCommand(fallbackMethod = "erroBook")    public Book buyBook() {        int a = 1 / 0; // 模拟服务提供者出错，给出备选解决方案给服务消费者        return bookService.sellBook();    }    private Book erroBook() {        return new Book().setName("error book").setPrice(0).setCode(110);    }}</code></pre></li></ol><h3><span id="hystrix-降级概念对于服务消费者">Hystrix 降级概念（对于服务消费者）</span></h3><p>​服务消费者调用服务提供者调不通，服务消费者自己给自己一个备选方案</p><ol><li><p>修改 api 模块中的 pom.xml</p><pre class=" language-language-xml"><code class="language-language-xml"><dependencies>        <dependency>            <groupid>org.springframework.cloud</groupid>            <artifactid>spring-cloud-starter-openfeign</artifactid>        </dependency>        <dependency>            <groupid>org.springframework.cloud</groupid>            <artifactid>spring-cloud-starter-netflix-hystrix</artifactid>        </dependency>    </dependencies></code></pre></li><li><p>新增一个实现 FallbackFactory 接口的类</p><p>新建一个 BookServiceFallbackFactory 类（名字自定义），传入对应的接口，<br>实现 FallbackFactory 中的接口，对接口中的方法进行降级处理<br>【@Component】 必须添加</p><pre class=" language-language-java"><code class="language-language-java">@Componentpublic class BookServiceFallbackFactory implements FallbackFactory<bookservice> {    @Override    public BookService create(Throwable throwable) { // 服务消费者主动处理        return () -> new Book().setName("服务降级").setPrice(10).setCode(119);    }}</bookservice></code></pre></li><li><p>修改服务消费者接口</p><pre class=" language-language-java"><code class="language-language-java">@FeignClient(value = "PROVIDER",fallbackFactory = BookServiceFallbackFactory.class)public interface BookService {    @GetMapping(value = "/buy/book")    Book sellBook();}</code></pre></li><li><p>Maven 发布 jar 包</p></li><li><p>带有 feign 的服务消费者修改yml</p><pre class=" language-language-yaml"><code class="language-language-yaml">feign:   hystrix:     enabled: true</code></pre></li><li><p>带有 feign 的服务消费者启动类修改</p><pre class=" language-language-java"><code class="language-language-java">@SpringBootApplication@EnableEurekaClient@EnableFeignClients(basePackages = {"com.fleawu"})//扫描 @FeignClient 标记的类@ComponentScan({"com.flea","com.fleawu"})// 包括熔断实现类也要扫描进来public class UserStart {    public static void main(String[] args) {        SpringApplication.run(UserStart.class, args);    }}</code></pre></li></ol><p>fallbackFactory 和 fallback 的区别</p>]]></content>
      
      
      
        <tags>
            
            <tag> 语言 </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud学习笔记(七) Feign 负载均衡</title>
      <link href="/article/springcloud-xue-xi-bi-ji-qi-feign-fu-zai-jun-heng/"/>
      <url>/article/springcloud-xue-xi-bi-ji-qi-feign-fu-zai-jun-heng/</url>
      
        <content type="html"><![CDATA[<h1><span id="springcloud学习笔记七-feign-负载均衡">SpringCloud学习笔记(七) Feign 负载均衡</span></h1><h3><span id="一-概念">一、概念</span></h3><p>​Feign 是一个声明式的 Web 服务客户端，使得编写 Web 服务客户端变得非常容易</p><h3><span id="二-使用">二、使用</span></h3><ol><li><p>新建 feign 项目（消费者）yml 相关配置</p><pre class=" language-language-yaml"><code class="language-language-yaml">server:  port: 8002spring:  application:    name: consumeeureka:  client:    service-url:      defaultZone: http://eureka01:6001/eureka/,http://eureka02:6002/eureka/,http://eureka03:6003/eureka/</code></pre></li><li><p>修改 feign 项目（消费者）pom</p><pre class=" language-language-xml"><code class="language-language-xml"> <dependencies>        <dependency>            <artifactid>api</artifactid>            <groupid>com.fleawu</groupid>            <version>1.0-SNAPSHOT</version>        </dependency>        <dependency>            <groupid>org.springframework.cloud</groupid>            <artifactid>spring-cloud-starter-netflix-eureka-client</artifactid>        </dependency>        <dependency>            <groupid>org.springframework.boot</groupid>            <artifactid>spring-boot-starter-web</artifactid>        </dependency>        <dependency>            <groupid>org.springframework.cloud</groupid>            <artifactid>spring-cloud-starter-ribbon</artifactid>        </dependency>   <!--导入openfeign的依赖，不同springboot版本和springcloud导入的依赖的版本可能不一样-->        <dependency>            <groupid>org.springframework.cloud</groupid>            <artifactid>spring-cloud-starter-openfeign</artifactid>        </dependency>    </dependencies></code></pre><ol start="3"><li>修改公共 api 模块 pom</li></ol><pre class=" language-language-xml"><code class="language-language-xml"><!--增加依赖--> <dependency>            <groupid>org.springframework.cloud</groupid>            <artifactid>spring-cloud-starter-openfeign</artifactid></dependency></code></pre><ol start="4"><li>公共 api 模块增加Service接口</li></ol><pre class=" language-language-java"><code class="language-language-java">/**PROVIDER：服务名称**/@FeignClient("PROVIDER")public interface BookService {    @GetMapping(value = "/buy/book")    Book sellBook();}</code></pre><ol start="5"><li>修改 feign 项目（消费者）主启动类</li></ol><pre class=" language-language-java"><code class="language-language-java">@SpringBootApplication()@EnableEurekaClient// basePackages = {"com.fleawu"} 为 API 模块中Service所在的包@EnableFeignClients(basePackages = {"com.fleawu"})public class UserStart {    public static void main(String[] args) {        SpringApplication.run(UserStart.class, args);    }}</code></pre><ol start="6"><li>修改 feign 项目（消费者）Controller</li></ol><pre class=" language-language-java"><code class="language-language-java">@RestControllerpublic class UserController {  // API 模块中的接口    @Resource    private BookService bookService;    @GetMapping(value = "/buybook")    public Book getuser() {        return bookService.sellBook();    }}</code></pre><ol start="7"><li><p>测试</p></li><li><p>启动注册中心 eureka</p></li><li><p>启动服务提供者（PROVIDER）：服务提供者注册进注册中心</p></li><li><p>启动带有 feign 的服务消费者</p></li><li><p>访问127.0.0.1:8002/buybook -----&gt; 访问的是服务提供者的：127.0.0.1:7001/buy/book 接口</p></li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 语言 </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud学习笔记(六) Ribbon 负载均衡</title>
      <link href="/article/springcloud-xue-xi-bi-ji-liu-ribbon-fu-zai-jun-heng/"/>
      <url>/article/springcloud-xue-xi-bi-ji-liu-ribbon-fu-zai-jun-heng/</url>
      
        <content type="html"><![CDATA[<h1><span id="springcloud学习笔记六-ribbon-负载均衡">SpringCloud学习笔记(六) Ribbon 负载均衡</span></h1><h3><span id="环境配置">环境配置</span></h3><ol><li><p>修改 pom 文件</p><pre class=" language-language-xml"><code class="language-language-xml"><!--添加 ribbon 依赖--><dependency>            <groupid>org.springframework.cloud</groupid>            <artifactid>spring-cloud-starter-ribbon</artifactid></dependency></code></pre></li><li><p>修改 RestTemplate 配置类添加：@LoadBalanced</p><pre class=" language-language-java"><code class="language-language-java">@Configurationpublic class ConfigBean {    @Bean    @LoadBalanced    public RestTemplate getRestTemplate() {        return new RestTemplate();    }}</code></pre></li><li><p>配置多个服务提供者</p><p>配置略</p><p>**注意：**Eureka注册同一个服务多个实例：instanceId 需不同</p><p>在application.propertis配置文件中配置参数eureka.instance.metadataMap.instanceId，不然可能注册到Eureka的相同服务的多个实例只有一个生效。</p><p>eureka.instance.metadataMap.instanceId: ${<a href="http://spring.application.name" target="_blank" rel="noopener">spring.application.name</a>}:${random.value}</p></li></ol><h3><span id="负载均衡">负载均衡</span></h3><ol><li><p>修改默认的轮询策略</p><pre class=" language-language-java"><code class="language-language-java"> @Bean    @LoadBalanced    public RestTemplate getRestTemplate() {        return new RestTemplate();    }// 上面代码不变    @Bean    public IRule ribbonRule() {        return new RandomRule(); //随机    }</code></pre></li><li><p>ribbon 负载均衡策略：</p><table><thead><tr><th><strong>策略类</strong></th><th><strong>命名</strong></th><th>描述</th></tr></thead><tbody><tr><td>RandomRule</td><td>随机策略</td><td>随机选择server</td></tr><tr><td>RoundRobinRule</td><td>轮询策略</td><td>按顺序选择server</td></tr><tr><td>RetryRule</td><td>重试策略</td><td>在一个配置时间段内当选择server不成功，则一直尝试选择一个可用的server</td></tr><tr><td>BestAvailableRule</td><td>最低并发策略</td><td>逐个考察server，如果server断路器打开，则忽略，在选择其中并发链接最低的server</td></tr><tr><td>AvailabilityFilteringRule</td><td>可用过滤策略</td><td>过滤掉一直链接失败并标记为circuit tripped的server，过滤掉哪些高并发链接</td></tr><tr><td>ResponseTimeWeightedRule</td><td>响应时间加权策略</td><td>根据server的响应时间分配权重。响应时间越长，权重越低，被选择到的概略就越低，权重越高，被选择到的概率就越高。</td></tr><tr><td>ZoneAvoidanceRule</td><td>区域权衡策略</td><td>综合判断server所在的区域的性能和server的可用性轮询选择server，并且判定一个AWS Zobe的运行性能是否可用，提出不可用的Zone中所有server。</td></tr></tbody></table></li><li><p>自定义负载均衡策略</p><ol><li><p>修改主启动类：</p><pre class=" language-language-java"><code class="language-language-java">@SpringBootApplication@EnableEurekaClient@RibbonClient(name = "PROVIDER",configuration = MyRule.class)public class UserStart {    public static void main(String[] args) {        SpringApplication.run(UserStart.class, args);    }}</code></pre><p>@RibbonClient(name = “PROVIDER”,configuration = MyRule.class)</p><p><strong>name</strong>：需要调用的微服务名称</p><p><strong>configuration</strong>：自定义负载均类；ps：该类需要实现 IRule 接口，并且不能放在 @ComponentScan 所扫描的当前包以及子包下（即不能放在主启动类的包及子包下）</p></li><li><p>创建 MyRule.class 类（先使用默认：RandomRule 配置）</p><pre class=" language-language-java"><code class="language-language-java">@Configurationpublic class MyRule {    @Bean    public IRule myRule() {        return new RandomRule();    }}</code></pre><p><strong>注意：</strong> 以上配置不能和以下一块使用</p><pre class=" language-language-java"><code class="language-language-java">@Bean    public IRule ribbonRule() {        return new RandomRule(); //随机    }</code></pre></li><li><p>自定义负载均衡：</p><pre class=" language-language-java"><code class="language-language-java">/**自定义的负载均衡算法*/public class MyRule extends AbstractLoadBalancerRule {    // total = 0 // 当total==5以后，我们指针才能往下走，    // index = 0 // 当前对外提供服务的服务器地址，    // total需要重新置为零，但是已经达到过一个5次，我们的index = 1    // 分析：我们5次，但是微服务只有8001 8002 8003 三台，OK？    private int total = 0;            // 总共被调用的次数，目前要求每台被调用5次    private int currentIndex = 0;    // 当前提供服务的机器号    public Server choose(ILoadBalancer lb, Object key) {        if (lb == null) {            return null;        }        Server server = null;        while (server == null) {            if (Thread.interrupted()) {                return null;            }            List<server> upList = lb.getReachableServers();            List<server> allList = lb.getAllServers();            int serverCount = allList.size();            if (serverCount == 0) {                return null;            }            //private int total = 0; // 总共被调用的次数，目前要求每台被调用5次            //private int currentIndex = 0; // 当前提供服务的机器号            if (total < 5) {                server = upList.get(currentIndex);                total++;            } else {                total = 0;                currentIndex++;                if (currentIndex >= upList.size()) {                    currentIndex = 0;                }            }            if (server == null) {                Thread.yield();                continue;            }            if (server.isAlive()) {                return (server);            }            server = null;            Thread.yield();        }        return server;    }     @Override    public Server choose(Object key) {        return choose(getLoadBalancer(), key);    }    @Override    public void initWithNiwsConfig(IClientConfig clientConfig) {    }}</server></server></code></pre></li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 语言 </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud学习笔记(五) eureka集群</title>
      <link href="/article/springcloud-xue-xi-bi-ji-wu-eureka-ji-qun/"/>
      <url>/article/springcloud-xue-xi-bi-ji-wu-eureka-ji-qun/</url>
      
        <content type="html"><![CDATA[<h1><span id="springcloud学习笔记五-eureka集群">SpringCloud学习笔记(五) eureka集群</span></h1><ol><li><p>新建多个 eureka 项目</p><p>Todo 创建项目省略</p></li><li><p>修改 host</p><pre class=" language-language-sh"><code class="language-language-sh">127.0.0.1 eureka01127.0.0.1 eureka02127.0.0.1 eureka03</code></pre></li><li><p>修改 yaml 文件</p><pre class=" language-language-yaml"><code class="language-language-yaml">server:  port: 6001eureka:  instance:    hostname: eureka01 #eureka 服务端的主机地址 修改  client:    register-with-eureka: false     fetch-registry: false     service-url:      defaultZone: http://eureka02:6002/eureka/,http://eureka03:6003/eureka/ #其他的eureka defaultZone</code></pre></li></ol><p><strong>zookeeper 和 eureka 相比 eureka 有什么优势</strong></p><p>​zookeeper：cp 原则，强一致 + 分布式</p><p>​eureka：ap 原则，高可用 + 分布式</p>]]></content>
      
      
      
        <tags>
            
            <tag> 语言 </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud学习笔记(四) eureka自我保护机制</title>
      <link href="/article/springcloud-xue-xi-bi-ji-si-eureka-zi-wo-bao-hu-ji-zhi/"/>
      <url>/article/springcloud-xue-xi-bi-ji-si-eureka-zi-wo-bao-hu-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h1><span id="springcloud学习笔记四-eureka自我保护机制">SpringCloud学习笔记(四) eureka自我保护机制</span></h1><p><strong>自我保护机制：</strong></p><p>​（好死不如赖活着）某时刻某一个微服务不可用了，eureka 不会立刻清理，依旧会对该微服务的信息进行保存。</p><p><strong>eureka是AP原则</strong></p><p><strong>如何禁用：</strong></p><p>​在 eureka server 端的配置文件中添加：</p><pre class=" language-language-properties"><code class="language-language-properties">eureka.server.enable-self-preservation=false</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 语言 </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud学习笔记(三) actuator与注册微服务信息完善</title>
      <link href="/article/springcloud-xue-xi-bi-ji-san-actuator-yu-zhu-ce-wei-fu-wu-xin-xi-wan-shan/"/>
      <url>/article/springcloud-xue-xi-bi-ji-san-actuator-yu-zhu-ce-wei-fu-wu-xin-xi-wan-shan/</url>
      
        <content type="html"><![CDATA[<h1><span id="springcloud学习笔记三-actuator与注册微服务信息完善">SpringCloud学习笔记(三) actuator与注册微服务信息完善</span></h1><h4><span id="修改-yaml-文件">修改 yaml 文件：</span></h4><pre class=" language-language-yaml"><code class="language-language-yaml">eureka:  client:    service-url:      defaultZone: http://localhost:6001/eureka  instance: # 新增    instance-id: provider_name #自定义服务名称信息    prefer-ip-address: true #服务路径可以显示ip地址</code></pre><h4><span id="info-信息完善">info 信息完善：</span></h4><ol><li><p>Client 工程引入 actuator gav</p><pre class=" language-language-xml"><code class="language-language-xml"><dependency>     <groupid>org.springframework.boot</groupid>     <artifactid>spring-boot-starter-actuator</artifactid></dependency></code></pre><p>actuator：主管监控和信息配置</p></li><li><p>在父工程中修改build （对springboot 2.x无效，2.x 直接跳过）</p><pre class=" language-language-xml"><code class="language-language-xml">    <build>        <finalname>eureka_demo</finalname>        <resources>            <resource>                <directory>src/main/resources</directory>                <filtering>true</filtering>            </resource>        </resources>        <plugins>            <plugin>                <groupid>org.apache.maven.plugins</groupid>                <artifactid>maven-resources-plugin</artifactid>                <configuration>                    <delimiters>                        <delimit>$</delimit>                    </delimiters>                </configuration>            </plugin>        </plugins>    </build></code></pre></li><li><p>Client  yml 增加相关信息</p><pre class=" language-language-yam"><code class="language-language-yam">info:  app.name: provider_seller  company.name: provider_seller_company_name  build.artifactId: @project.artifactId@ #springboot 2.x 使用@动态获取，其他版本需根据具体情况调整  build.version: @project.version@</code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 语言 </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud学习笔记(二)eureka 环境配置</title>
      <link href="/article/springcloud-xue-xi-bi-ji-er-eureka/"/>
      <url>/article/springcloud-xue-xi-bi-ji-er-eureka/</url>
      
        <content type="html"><![CDATA[<h1><span id="springcloud学习笔记二-eureka-环境配置">SpringCloud学习笔记(二) eureka 环境配置</span></h1><h3><span id="建立在无主pom的情况下">建立在无主pom的情况下</span></h3><h4><span id="eureka-server-配置">Eureka Server 配置:</span></h4><ol><li><p>Pom.xml 配置</p><pre class=" language-language-xml"><code class="language-language-xml"><dependency>  <groupid>org.springframework.cloud</groupid>  <artifactid>spring-cloud-dependencies</artifactid>  <version>Finchley.RELEASE</version></dependency><dependency><groupid>org.springframework.cloud</groupid><artifactid>spring-cloud-starter-netflix-eureka-server</artifactid></dependency></code></pre></li><li><p>启动类配置</p><pre class=" language-language-java"><code class="language-language-java">@SpringBootApplication@EnableEurekaServer //开启EurekaServerpublic class EurekaStart {    public static void main(String[] args) {        SpringApplication.run(EurekaStart.class, args);    }}</code></pre></li><li><p>yml 配置</p><pre class=" language-language-yml"><code class="language-language-yml">server:  port: 6001eureka:  instance:    hostname: eurekaDemo #eureka 服务端的实例名称  client:    register-with-eureka: false #false 表示不向注册中心注册自己    fetch-registry: false #false 表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务    service-url:      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka</code></pre></li></ol><h4><span id="eureka-client-配置">Eureka client 配置:</span></h4><ol><li><p>Pom.xml 配置</p><pre class=" language-language-xml"><code class="language-language-xml"><dependency>  <groupid>org.springframework.cloud</groupid>  <artifactid>spring-cloud-dependencies</artifactid>  <version>Finchley.RELEASE</version></dependency><dependency>  <groupid>org.springframework.cloud</groupid>  <artifactid>spring-cloud-starter-netflix-eureka-client</artifactid></dependency></code></pre></li><li><p>启动类配置</p><pre class=" language-language-java"><code class="language-language-java">@SpringBootApplication@EnableEurekaClient //开启 eureka 客户端public class SellerStart {    public static void main(String[] args) {        SpringApplication.run(SellerStart.class, args);    }}</code></pre></li><li><p>yml 配置</p><pre class=" language-language-yaml"><code class="language-language-yaml">server:  port: 7001spring:  application:    name: providereureka:  client:    service-url:      defaultZone: http://localhost:6001/eureka</code></pre></li></ol><h3><span id="建立在有主pom的情况下">建立在有主pom的情况下</span></h3><h4><span id="eureka-server-配置">Eureka Server 配置:</span></h4><ol><li><p>主 pom 配置</p><pre class=" language-language-xml"><code class="language-language-xml"><dependencymanagement>        <dependencies>            <dependency>                <groupid>org.springframework.cloud</groupid>                <artifactid>spring-cloud-dependencies</artifactid>                <version>Finchley.RELEASE</version>                <type>pom</type>                <scope>import</scope>            </dependency>        </dependencies></dependencymanagement></code></pre></li><li><p>Eureka Server pom 配置</p><pre class=" language-language-xml"><code class="language-language-xml"><dependencies>        <dependency>            <groupid>org.springframework.cloud</groupid>            <artifactid>spring-cloud-starter-netflix-eureka-server</artifactid>        </dependency></dependencies></code></pre></li><li><p>Eureka Server 启动类配置</p><pre class=" language-language-java"><code class="language-language-java">@SpringBootApplication@EnableEurekaServer //开启 eureka 客户端public class EurekaStart {    public static void main(String[] args) {        SpringApplication.run(EurekaStart.class, args);    }}</code></pre></li><li><p>Eureka Server yml 配置</p><pre class=" language-language-yml"><code class="language-language-yml">server:  port: 6001eureka:  instance:    hostname: eurekaDemo #eureka 服务端的实例名称  client:    register-with-eureka: false #false 表示不向注册中心注册自己    fetch-registry: false #false 表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务    service-url:      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka</code></pre></li><li><p>Eureka client pom 配置</p><pre class=" language-language-xml"><code class="language-language-xml"> <dependency>            <groupid>org.springframework.cloud</groupid>            <artifactid>spring-cloud-starter-netflix-eureka-client</artifactid></dependency></code></pre></li><li><p>Eureka clinet 启动类配置</p><pre class=" language-language-java"><code class="language-language-java">@SpringBootApplication@EnableEurekaClientpublic class SellerStart {    public static void main(String[] args) {        SpringApplication.run(SellerStart.class, args);    }}</code></pre></li><li><p>Eureka clinet yml 配置</p><pre class=" language-language-yaml"><code class="language-language-yaml">server:  port: 7001spring:  application:    name: providereureka:  client:    service-url:      defaultZone: http://localhost:6001/eureka</code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 语言 </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud学习笔记(一)</title>
      <link href="/article/springcloud-xue-xi-bi-ji-yi/"/>
      <url>/article/springcloud-xue-xi-bi-ji-yi/</url>
      
        <content type="html"><![CDATA[<h1><span id="springcloud学习笔记一">SpringCloud学习笔记(一)</span></h1><p><strong>学习网站</strong></p><blockquote><p><a href="https://www.springcloud.cc/" target="_blank" rel="noopener">https://www.springcloud.cc/</a></p></blockquote><p>搭建两个应用之间使用 RestTemplate 调用</p><p>配置类：</p><pre class=" language-language-java"><code class="language-language-java">@Configurationpublic class ConfigBean {    @Bean    public RestTemplate getRestTemplate() {        return new RestTemplate();    }}</code></pre><p>Controller：</p><pre class=" language-language-java"><code class="language-language-java">@RestControllerpublic class UserController {    @Resource    private RestTemplate restTemplate;    @GetMapping(value = "/buybook")    public Book getuser() {        return restTemplate.getForObject("http://127.0.0.1:7001/buy/book", Book.class);    }}</code></pre><p>RestTemplate 底层原理是 http调用</p>]]></content>
      
      
      
        <tags>
            
            <tag> 语言 </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Docker搭建Nexus私服</title>
      <link href="/article/yong-docker-da-jian-nexus-si-fu/"/>
      <url>/article/yong-docker-da-jian-nexus-si-fu/</url>
      
        <content type="html"><![CDATA[<h1><span id="用docker搭建nexus私服">用Docker搭建Nexus私服</span></h1><ol><li><p>搜索镜像</p><pre class=" language-language-sh"><code class="language-language-sh">docker search nexus</code></pre></li><li><p>拉取镜像</p><pre class=" language-language-sh"><code class="language-language-sh">docker pull sonatype/nexus3</code></pre></li><li><p>创建Nexus数据文件的挂载目录</p><pre class=" language-language-sh"><code class="language-language-sh">mkdir /home/nexus</code></pre></li><li><p>通过Nexus镜像创建Nexus容器并运行</p><pre class=" language-language-sh"><code class="language-language-sh">docker run -itd -p 8081:8081 --name nexus  --restart always -v /home/nexus:/nexus-data  sonatype/nexus3</code></pre></li><li><p>查看是否已经启动</p><pre class=" language-language-sh"><code class="language-language-sh">docker ps -a</code></pre></li><li><p>查看日志是否正常</p><pre><code>docker logs nexus容器Id</code></pre><p>若出现报错日志，将宿主机中的文件夹目录权限修改</p><pre class=" language-language-sh"><code class="language-language-sh">chmod 777 /home/nexus</code></pre></li><li><p>访问 nexus 页面</p><pre><code>http://ip地址:8081/</code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>私有maven仓库的搭建(nexus)</title>
      <link href="/article/si-you-maven-cang-ku-de-da-jian-nexus/"/>
      <url>/article/si-you-maven-cang-ku-de-da-jian-nexus/</url>
      
        <content type="html"><![CDATA[<h1><span id="私有maven仓库的搭建">私有Maven仓库的搭建</span></h1><ol><li><p>下载 nexus 压缩包</p><pre class=" language-language-sh"><code class="language-language-sh">wget http://download.sonatype.com/nexus/3/nexus-3.7.1-02-unix.tar.gz</code></pre></li><li><p>解压nexus安装包</p><pre class=" language-language-sh"><code class="language-language-sh">tar zxvf nexus-3.7.1-02-unix.tar.gz</code></pre></li><li><p>配置nexus的环境变量</p><pre class=" language-language-sh"><code class="language-language-sh">vim /etc/profile</code></pre></li><li><p>在profile文件的最底下加上这两行</p><pre class=" language-language-sh"><code class="language-language-sh">export MAVEN_HOME=/usr/software/nexus-3.7.1-02export PATH=$PATH:$MAVEN_HOME/bin</code></pre><p>注：MAVEN_HOME的地址指向刚刚解压的地址</p></li><li><p>保存profile文件，并刷新</p><pre class=" language-language-sh"><code class="language-language-sh">source /etc/profile</code></pre></li><li><p>启动nexus服务</p><pre class=" language-language-sh"><code class="language-language-sh">nexus start</code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nexus 使用</title>
      <link href="/article/nexus-shi-yong/"/>
      <url>/article/nexus-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1><span id="nexus-使用">Nexus 使用</span></h1><ol><li><p>创建 Blob 存储</p><p><img src="https://img.nbjike.com/jietu/20200215172508.png" alt></p><img src="https://img.nbjike.com/jietu/20200215172820.png"></li><li><p>创建仓库</p></li><li><p>配置server</p><p><img src="https://img.nbjike.com/jietu/20200215174816.png" alt></p><pre class=" language-language-xml"><code class="language-language-xml"><!--此处设置的用户名和密码都是nexus的登陆配置-->  <server>        <id>release_user</id><!--对应pom.xml的id=releases的仓库-->        <username>admin</username>        <password>nexus123456</password>    </server>     <server>        <id>snapshot_user</id><!--对应pom.xml中id=snapshots的仓库-->        <username>admin</username>        <password>nexus123456</password>    </server></code></pre></li></ol><ol start="4"><li><p>在 Java 项目 pom 中添加</p><pre class=" language-language-pom"><code class="language-language-pom"><distributionmanagement>        <!--发布jar包到私服-->        <repository>            <id>release_user</id>            <name>Release Deploy</name>            <url>http://101.133.169.16:8081/repository/maven-releases/</url>        </repository>        <!--<snapshotRepository>-->            <!--<id>snapshot_user</id>-->            <!--<name>Snapshot Deploy</name>-->            <!--<url>http://localhost:8081/repository/maven-snapshots/</url>-->        <!--</snapshotRepository>--></distributionmanagement></code></pre></li><li><p>注意事项</p><p>发jar包的版本不能是：SNAPSHOT结尾</p></li><li><p>从私服拉取jar包</p><pre class=" language-language-xml"><code class="language-language-xml"><profile><id>developer</id><activation><jdk>jdk-1.8</jdk></activation><!-- 所有请求均通过镜像，配置一个假的中央仓库地址，重写中央仓库的路径地址 --><repositories><repository><id>nexus</id><name>local private nexus</name><url>http://101.133.169.16:8081/repository/maven-public/</url><releases><enabled>true</enabled></releases><snapshots><enabled>true</enabled></snapshots></repository></repositories><pluginrepositories><pluginrepository><id>nexus</id><name>local private nexus</name><url>http://101.133.169.16:8081/repository/maven-public/</url><releases><enabled>true</enabled></releases><snapshots><enabled>true</enabled></snapshots></pluginrepository></pluginrepositories></profile> </code></pre></li></ol><blockquote><p><a href="https://www.ppkanshu.com/index.php/post/4043.html" target="_blank" rel="noopener">参见</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Nexus使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Axios 使用</title>
      <link href="/article/axios-shi-yong/"/>
      <url>/article/axios-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1><span id="axios-使用">Axios 使用</span></h1><ol><li><p>get 和 post 传参</p><p><img src="https://img.nbjike.com/jietu/20200212221506.png" alt></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java9 基础内容</title>
      <link href="/article/java9-ji-chu-nei-rong/"/>
      <url>/article/java9-ji-chu-nei-rong/</url>
      
        <content type="html"><![CDATA[<h1><span id="java9-基础内容">Java9 基础内容</span></h1><p>JEP：jdk enhancement proposals  =&gt; jdk 改进提案，一种非正式的规范</p><p>JSR：Java</p>]]></content>
      
      
      
        <tags>
            
            <tag> 语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue学习（二）脚手架目录结构说明</title>
      <link href="/article/vue-xue-xi-er-jiao-shou-jia-mu-lu-jie-gou-shuo-ming/"/>
      <url>/article/vue-xue-xi-er-jiao-shou-jia-mu-lu-jie-gou-shuo-ming/</url>
      
        <content type="html"><![CDATA[<h1><span id="vue学习二脚手架目录结构说明">Vue学习（二）脚手架目录结构说明</span></h1><ol><li>脚手架目录示意图：</li></ol><p><img src="https://img.nbjike.com/jietu/20200229235424.png" alt></p><ol start="2"><li><p>目录结构说明：</p><p>一级目录:</p><p><strong>build</strong>： webpack 配置相关的目录<br><strong>config</strong>： webpack 配置相关的目录<br><strong>node_modules</strong>：npm install 安装的依赖代码库<br><strong>src</strong>：我们存放的源码，我们开发的所有代码都放在src目录下。<br><strong>staic</strong>：存放一些第三方静态资源的目录<br><strong>test</strong>：测试目录，没有太大用处，可以删除</p></li></ol><p>一级文件:</p><p>.<strong>babelrc</strong>：babel的一些配置，（将es6编译成es5的一些配置）<br>.<strong>editorconfig</strong>：编辑器的一些配置（包括编码格式，缩进风格，换行格式）<br>.<strong>eslintignore</strong>：配置我们不会对build文件和config文件进行语法检查。<br>.<strong>eslintrc.js</strong>：eslint的配置文件，主要是定义一些代码编写风格的规则。<br>.<strong>gitignore</strong>：配置git仓库忽略的一些文件（不会上传）<br><strong>index.html</strong>： 入口html 文件。<br><strong>package.json</strong>：项目的一些配置信息（项目的一些具体信息）</p><p>src 文件夹下:</p><p><strong>assets</strong> 文件夹： 存放静态资源，例如：图片，font字体等。<br><strong>conponents</strong> 文件夹： 存放组件，里面你可以在建文件来分组件，比如建 header 问价夹， footer 文件夹<br><strong>router</strong> 文件夹： 配置路由文件<br><strong>App.vue</strong> 文件： App.vue是我们的主组件，所有页面都是在App.vue下进行切换的<br><strong>main.js</strong> 文件：主要作用是初始化vue实例并使用需要的插件</p>]]></content>
      
      
      
        <tags>
            
            <tag> Vue脚手架 </tag>
            
            <tag> 配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抓包工具Proxyman使用</title>
      <link href="/article/zhua-bao-gong-ju-proxyman-shi-yong/"/>
      <url>/article/zhua-bao-gong-ju-proxyman-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1><span id="抓包工具proxyman使用">抓包工具Proxyman使用</span></h1><ol><li><p>打开开启抓包证书安装</p><p><img src="https://img.nbjike.com/jietu/20200212003451.png" alt="安装结果"></p></li><li><p>手机抓包</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 效率 </tag>
            
            <tag> 抓包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chrome 插件开发(二)manifest.json配置</title>
      <link href="/article/chrome-cha-jian-kai-fa-er-manifest.json-pei-zhi/"/>
      <url>/article/chrome-cha-jian-kai-fa-er-manifest.json-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h1><span id="chrome-插件开发二manifestjson配置">Chrome 插件开发(二)manifest.json配置</span></h1><h3><span id="manifestjson-配置说明">manifest.json 配置说明：</span></h3><pre class=" language-language-json"><code class="language-language-json">{  "manifest_version": 2,  "name": "插件名称",  "description": "插件描述",  "version": "1.0.0",  "background": {    "scripts": [      "js/axios.min.js",      "js/background.js"    ]  },  "permissions": [    "contextMenus",    "tabs",    "cookies",    "storage",    "*://*/*"  ],  "content_scripts": [    {      "matches": [        "*://star.toutiao.com/*"      ],      "js": [        "js/axios.min.js",        "js/contentscripts.js"      ],      "run_at": "document_end"    }  ],  "browser_action": {    "default_icon": "logo.png",    "default_title": "插件描述",    "default_popup": "popup.html"  },  "content_security_policy": "script-src 'self' 'unsafe-eval'; object-src 'self'"}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 脚本 </tag>
            
            <tag> 插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 安装redis（配置启动）</title>
      <link href="/article/docker-an-zhuang-redis-pei-zhi-qi-dong/"/>
      <url>/article/docker-an-zhuang-redis-pei-zhi-qi-dong/</url>
      
        <content type="html"><![CDATA[<h1><span id="docker-安装redis配置启动">Docker 安装redis（配置启动）</span></h1><ol><li><p>拉取 redis 镜像</p><pre class=" language-language-sh"><code class="language-language-sh">docker pull redis</code></pre></li><li><p>创建redis.conf和相应的文件夹</p><p><a href="http://download.redis.io/redis-stable/redis.conf" target="_blank" rel="noopener">redis官方配置文件</a></p><blockquote><p>记得修改 bind，直接注释或bind 0.0.0.0</p></blockquote></li><li><p>启动redis</p><pre class=" language-language-sh"><code class="language-language-sh">docker run -d -p 6379:6379 \--name redis \-v /home/config/redis/redis.conf:/etc/redis/redis.conf \-v /home/data/redis:/data \redis \redis-server /etc/redis/redis.conf  --appendonly yes</code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 环境搭建 </tag>
            
            <tag> redis安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue学习（一）使用Vue脚手架创建Vue项目</title>
      <link href="/article/vue-shi-yong-vue-jiao-shou-jia-chuang-jian-vue-xiang-mu/"/>
      <url>/article/vue-shi-yong-vue-jiao-shou-jia-chuang-jian-vue-xiang-mu/</url>
      
        <content type="html"><![CDATA[<h1><span id="vue学习一使用vue脚手架创建vue项目">Vue学习（一）使用Vue脚手架创建Vue项目</span></h1><ol><li><p>安装 node 环境</p></li><li><p>安装 npm</p></li><li><p>安装 vue</p><pre class=" language-language-sh"><code class="language-language-sh">npm install -g vue-cli</code></pre></li><li><p>初始化vue脚手架</p><pre class=" language-language-sh"><code class="language-language-sh">vue init webpack 项目名</code></pre></li><li><p>选择配置</p><p><img src="https://img.nbjike.com/jietu/20200210002830.png" alt></p></li><li><p>配置说明</p><pre class=" language-language-sh"><code class="language-language-sh"># 项目名称? Project name y# 项目描述? Project description vue脚手架学习vue# 作者邮箱? Author zaydanwu@gmail.com#? Vue build standalone# 是否安装 vue-router? Install vue-router? Yes#? Use ESLint to lint your code? Yes# 选择一个 eslint 标准，Airbnb? Pick an ESLint preset Standard# 是否安装单元测试? Set up unit tests Yes# 选择jtest? Pick a test runner jest? Setup e2e tests with Nightwatch? Yes? Should we run `npm install` for you after the project has been created? (recommended) npm</code></pre></li><li><p>安装成功</p><p><img src="https://img.nbjike.com/jietu/20200210003831.png" alt></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 环境搭建 </tag>
            
            <tag> Vue脚手架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker部署jar包</title>
      <link href="/article/docker-bu-shu-jar-bao/"/>
      <url>/article/docker-bu-shu-jar-bao/</url>
      
        <content type="html"><![CDATA[<h1><span id="docker部署jar包">Docker部署jar包</span></h1><h3><span id="方式一">方式一：</span></h3><blockquote><p>这种方式就是运行一个jdk的容器，然后挂载其中的目录到宿主机，然后运行之后，就可以将需要运行的jar放在宿主机的挂载目录下，然后每次重新运行docker容器即可。不用每次发布需要重新构建docker容器，只需要替换宿主机中的jar包即可</p></blockquote><ol><li><p>docker 拉取 jdk 镜像</p><pre class=" language-language-sh"><code class="language-language-sh">docker pull openjdk</code></pre></li><li><p>准备jar包</p></li><li><p>关联宿主机含有jar包的文件夹和容器中的文件夹</p><pre class=" language-language-sh"><code class="language-language-sh">docker run -d \--restart=always \-v /home/codes/deploy/jar:/jar -v /var/log/redis:/var/log/redis \-p 5678:5678 \--name redis_jar openjdk \/usr/bin/java -jar \/jar/redis.jar# -d 后台运行# --restart=always 这个表示docker容器在停止重新启动或服务器开机之后，镜像会自动重新启动# -v 挂载目录# --name 别名# openjdk 容器名# /usr/bin/java -jar 启动jar包# /jar/redis.jar 镜像中的jar包</code></pre></li><li><p>更新jar包</p><p>只需要将新的jar包，拷贝到挂载目录，重启镜像</p></li></ol><h3><span id="方式二">方式二：</span></h3><blockquote><p>制作脚本，通过镜像每次执行脚本，通过脚本去执行更新后的jar包（需要挂载目录）</p></blockquote><ol><li><p>编写脚本</p><pre class=" language-language-sh"><code class="language-language-sh">java -jar /demo/redis.sh</code></pre></li><li><p>编写Dockerfile</p><pre class=" language-language-do"><code class="language-language-do">FROM java:8EXPOSE 5678ENTRYPOINT ["sh","/demo/redis.sh"]</code></pre></li><li><p>将jar包和脚本放置在同一目录下</p></li><li><p>执行docker命令</p><pre class=" language-language-sh"><code class="language-language-sh">docker run  -d --name redis1 \-it \ -v /home/codes/deploy/demo:/demo -v /var/log/redis/:/var/log/redis/ -p 5678:5678 redis_demo</code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chrome 插件开发(一)基础知识了解</title>
      <link href="/article/chrome-cha-jian-kai-fa-yi-ji-chu-zhi-shi-liao-jie/"/>
      <url>/article/chrome-cha-jian-kai-fa-yi-ji-chu-zhi-shi-liao-jie/</url>
      
        <content type="html"><![CDATA[<h1><span id="chrome-插件开发一基础知识了解">Chrome 插件开发(一)基础知识了解</span></h1><h3><span id="编辑扩展程序所需要的主要文件夹">编辑扩展程序所需要的主要文件夹</span></h3><pre><code> ./ ├─ manifest.json //扩展的配置项 ├─ Custom.js     //自定义js脚本 ├─ Custom.css    //自定义css样式 ├─ icon.png      //扩展程序的icon └─ popup.html    //扩展的展示弹窗</code></pre><p><strong>1.popup</strong></p><p>用户鼠标点击插件图标弹出的界面 popup.html 对应的js：叫 popup.js（自定义js脚本，可以叫别的名称）</p><p><img src="https://img.nbjike.com/jietu/20200202164917.png" alt="如图所示"></p><ol start="2"><li>Chrome 开发注意事项：</li></ol><blockquote><p><a href="https://www.jianshu.com/p/6422a1c4b6f2" target="_blank" rel="noopener">https://www.jianshu.com/p/6422a1c4b6f2</a></p><p><a href="https://segmentfault.com/a/1190000020525962?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000020525962?utm_source=tag-newest</a></p><p><a href="http://blog.haoji.me/chrome-plugin-develop.html" target="_blank" rel="noopener">http://blog.haoji.me/chrome-plugin-develop.html</a></p><p>e.g.:</p><p><a href="https://github.com/spademan/get-cookie-in-chrome" target="_blank" rel="noopener">https://github.com/spademan/get-cookie-in-chrome</a></p><p><a href="https://www.cnblogs.com/liuxianan/p/chrome-plugin-develop.html" target="_blank" rel="noopener">https://www.cnblogs.com/liuxianan/p/chrome-plugin-develop.html</a></p><p>较详细的文档：</p><p><a href="https://github.com/sxei/chrome-plugin-demo" target="_blank" rel="noopener">https://github.com/sxei/chrome-plugin-demo</a></p><p>chrome插件消息交互：</p><p><a href="https://blog.csdn.net/summerxiachen/article/details/78698878" target="_blank" rel="noopener">https://blog.csdn.net/summerxiachen/article/details/78698878</a></p></blockquote><ol start="3"><li><p>webstorm 设置chrome提示</p><pre><code>1. 打开Settings对话框（File&gt; Settings）2. 点击Languages &amp; Frameworks&gt; Javascript&gt;Libraries3. 点击 Download4. 确保TypeScript community stubs已选中5. chrome从列表中选择（只需键入即可快速找到它chrome）6. 点击 Download and Install7. 点击OK关闭设置对话框</code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 脚本 </tag>
            
            <tag> 插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos7 安装jdk 11</title>
      <link href="/article/centos7-an-zhuang-jdk-11/"/>
      <url>/article/centos7-an-zhuang-jdk-11/</url>
      
        <content type="html"><![CDATA[<h1><span id="centos7-安装jdk-11">Centos7 安装jdk 11</span></h1><ol><li><p>首先搜索可安装的 JDK</p><pre class=" language-language-sh"><code class="language-language-sh">sudo yum search java-11</code></pre></li><li><p>搜索结果</p><pre class=" language-language-sh"><code class="language-language-sh">=========================================================================================== N/S matched: java-11 ===========================================================================================java-11-openjdk.i686 : OpenJDK Runtime Environment 11java-11-openjdk.x86_64 : OpenJDK Runtime Environment 11java-11-openjdk-debug.i686 : OpenJDK Runtime Environment 11 with full debug onjava-11-openjdk-debug.x86_64 : OpenJDK Runtime Environment 11 with full debug onjava-11-openjdk-demo.i686 : OpenJDK Demos 11java-11-openjdk-demo.x86_64 : OpenJDK Demos 11java-11-openjdk-demo-debug.i686 : OpenJDK Demos 11 with full debug onjava-11-openjdk-demo-debug.x86_64 : OpenJDK Demos 11 with full debug onjava-11-openjdk-devel.i686 : OpenJDK Development Environment 11java-11-openjdk-devel.x86_64 : OpenJDK Development Environment 11java-11-openjdk-devel-debug.i686 : OpenJDK Development Environment 11 with full debug onjava-11-openjdk-devel-debug.x86_64 : OpenJDK Development Environment 11 with full debug onjava-11-openjdk-headless.i686 : OpenJDK Headless Runtime Environment 11java-11-openjdk-headless.x86_64 : OpenJDK Headless Runtime Environment 11java-11-openjdk-headless-debug.i686 : OpenJDK Runtime Environment with full debug onjava-11-openjdk-headless-debug.x86_64 : OpenJDK Runtime Environment with full debug onjava-11-openjdk-javadoc.i686 : OpenJDK 11 API documentationjava-11-openjdk-javadoc.x86_64 : OpenJDK 11 API documentationjava-11-openjdk-javadoc-debug.i686 : OpenJDK 11 API documentation for packages with debug onjava-11-openjdk-javadoc-debug.x86_64 : OpenJDK 11 API documentation for packages with debug onjava-11-openjdk-javadoc-zip.i686 : OpenJDK 11 API documentation compressed in single archivejava-11-openjdk-javadoc-zip.x86_64 : OpenJDK 11 API documentation compressed in a single archivejava-11-openjdk-javadoc-zip-debug.i686 : OpenJDK 11 API documentation compressed in single archive for packages with debug onjava-11-openjdk-javadoc-zip-debug.x86_64 : OpenJDK 11 API documentation compressed in a single archive for packages with debug onjava-11-openjdk-jmods.i686 : JMods for OpenJDK 11java-11-openjdk-jmods.x86_64 : JMods for OpenJDK 11java-11-openjdk-jmods-debug.i686 : JMods for OpenJDK 11 with full debug onjava-11-openjdk-jmods-debug.x86_64 : JMods for OpenJDK 11 with full debug onjava-11-openjdk-src.i686 : OpenJDK Source Bundle 11java-11-openjdk-src.x86_64 : OpenJDK Source Bundle 11java-11-openjdk-src-debug.i686 : OpenJDK Source Bundle 11 for packages with debug onjava-11-openjdk-src-debug.x86_64 : OpenJDK Source Bundle 11 for packages with debug on</code></pre></li><li><p>yum 安装</p><pre class=" language-language-sh"><code class="language-language-sh">yum install java-11-openjdk.x86_64</code></pre></li><li><p>安装的路径</p><pre class=" language-language-sh"><code class="language-language-sh">cd /usr/lib/jvm</code></pre></li><li><p>查看安装的版本</p><pre class=" language-language-sh"><code class="language-language-sh">java -version</code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua 学习</title>
      <link href="/article/lua-xue-xi/"/>
      <url>/article/lua-xue-xi/</url>
      
        <content type="html"><![CDATA[<p>Lua 环境安装</p><pre class=" language-language-shell"><code class="language-language-shell">curl -R -O http://www.lua.org/ftp/lua-5.3.5.tar.gztar zxf lua-5.3.5.tar.gzcd lua-5.3.5make linux test#报错执行yum install libtermcap-devel ncurses-devel libevent-devel readline-develmake install</code></pre><p>出现如图所示，表示安装成功</p><p><img src="https://img.nbjike.com/jietu/20200125205302.png" alt="最终结果"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IaaS，PaaS，SaaS 的区别</title>
      <link href="/article/iaas-paas-saas-de-qu-bie/"/>
      <url>/article/iaas-paas-saas-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<h1><span id="iaaspaassaas-的区别">IaaS，PaaS，SaaS 的区别</span></h1><p><strong>IaaS：基础设施服务</strong></p><p>​例如：提供基础生产工具，（卖加工原材料的<strong>工具</strong>的）</p><p><strong>PaaS：平台服务</strong></p><p>​例如：不仅提供原材料加工工具，又提供加工原材料服务（你只需要提供原材料）</p><p><strong>SaaS：软件即服务</strong></p><p>​例如：你无需做任何事情，就可以获取到产品</p>]]></content>
      
      
      
        <tags>
            
            <tag> 名词解释 </tag>
            
            <tag> 专业名词 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作总结模板</title>
      <link href="/article/nian-zhong-zong-jie-mo-ban/"/>
      <url>/article/nian-zhong-zong-jie-mo-ban/</url>
      
        <content type="html"><![CDATA[<h1><span id="工作总结模板">工作总结模板</span></h1><p>[toc]</p><h3><span id="总体框架目录">总体框架目录</span></h3><p>单独一张PPT，把一些要讲的内容罗列出来</p><h3><span id="第一部分">第一部分</span></h3><p>简述今年的主要工作重心</p><p>快速回顾今年工作重心，如果有必要，也应该对比去年。</p><h3><span id="第二部分">第二部分</span></h3><p>都做了哪些具体的事情</p><p>事情 1：做到什么样，我的作用，产出了什么，价值是什么…</p><p>事情 2：做到什么样，我的作用，产出了什么，价值是什么…</p><p>事情 3：做到什么样，我的作用，产出了什么，价值是什么…</p><p>事情 4：…</p><p>还曾受到同事肯定/客户表扬/用户认可，如果自己觉得好意思，脸上贴点金也无妨，佐证自己工作的成效。</p><h3><span id="第三部分">第三部分</span></h3><p>问题和遗憾的部分</p><p>某个工作目标 ：没怎么做好，原因是…尽量客观，理性，尤其注意别推脱责任。</p><h3><span id="第四部分">第四部分</span></h3><p>自我评定</p><p>自己认为的绩效应该是… 主要理由和原因是…</p><h3><span id="第五部分">第五部分</span></h3><p>明年的工作计划</p><p>明年，学习管理技能/学习新技术/探索新的业务领域…</p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 工作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA 调用浏览器获取数据</title>
      <link href="/article/java-diao-yong-liu-lan-qi-huo-qu-shu-ju/"/>
      <url>/article/java-diao-yong-liu-lan-qi-huo-qu-shu-ju/</url>
      
        <content type="html"><![CDATA[<h1><span id="java-调用浏览器获取页面中的数据">JAVA 调用浏览器获取页面中的数据</span></h1><pre class=" language-language-java"><code class="language-language-java">//调用浏览器WebDriver webDriver = new ChromeDriver();webDriver.get("https://s.click.taobao.com/t?e=m%3D2%26s%3DtrHIghuGQt1w4vFB6t2Z2ueEDrYVVa64XoO8tOebS%2BdRAdhuF14FMQ03gou%2BipfClovu%2FCElQOvickge4xxVNR9dy868BwtVVbV2OUE6VFIEUwKUjNqrT2U%2FUaldK2D4grXFxOS2hWW5j1IKE4qwcAtkyqhBb5%2B4HoaaUnJGJVMk6A8vppGneNAxZcmeIBxWj3Mk01PT8yxtL2w68yOxvE9RNdF9PG1054D9O%2FIWQ4%2BVlMEqA3PwTyB4b8xwNKLSxg5p7bh%2BFbQ%3D&union_lens=lensId:0bb39b78_1875_16b0def307e_aa33");String currentUrl = webDriver.getCurrentUrl();System.out.println(currentUrl);//代理请求OkHttpClient okHttpClient = new OkHttpClient();Request.Builder builder = new Request.Builder();builder.url("xx");builder.get();Request request = builder.build();String string = Objects.requireNonNull(okHttpClient.newCall(request).execute().body()).string();JSONObject jsonObject = JSONObject.parseObject(string);JSONArray data = jsonObject.getJSONArray("data");JSONObject object = (JSONObject) data.get(0);String ip = object.getString("ip");Integer port = object.getInteger("port");String httpProxy = String.join(":", ip, port + "");ChromeOptions chromeOptions = new ChromeOptions();Proxy proxy = new Proxy();proxy.setHttpProxy(httpProxy);chromeOptions.setProxy(proxy);System.out.println(httpProxy);chromeOptions.addArguments("headless");chromeOptions.addArguments("no-sandbox");WebDriver webDriver = new ChromeDriver(chromeOptions);webDriver.get("https://s.click.taobao.com/t?e=m%3D2%26s%3DtrHIghuGQt1w4vFB6t2Z2ueEDrYVVa64XoO8tOebS%2BdRAdhuF14FMQ03gou%2BipfClovu%2FCElQOvickge4xxVNR9dy868BwtVVbV2OUE6VFIEUwKUjNqrT2U%2FUaldK2D4grXFxOS2hWW5j1IKE4qwcAtkyqhBb5%2B4HoaaUnJGJVMk6A8vppGneNAxZcmeIBxWj3Mk01PT8yxtL2w68yOxvE9RNdF9PG1054D9O%2FIWQ4%2BVlMEqA3PwTyB4b8xwNKLSxg5p7bh%2BFbQ%3D&union_lens=lensId:0bb39b78_1875_16b0def307e_aa33");String currentUrl = webDriver.getCurrentUrl();System.out.println(currentUrl);</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信开发 Java</title>
      <link href="/article/wei-xin-kai-fa-java/"/>
      <url>/article/wei-xin-kai-fa-java/</url>
      
        <content type="html"><![CDATA[<h1><span id="微信开发-java">微信开发 Java</span></h1><h3><span id="1-服务号java服务端开发">1. 服务号Java服务端开发</span></h3><blockquote><p>$\underline{需要的数据:}$</p><p>服务号的appId、appSecret 用于获取 AccessToken</p><p><a href="https://api.weixin.qq.com/cgi-bin/user/info?access_token=%25s&amp;openid=%25s&amp;lang=zh_CN" target="_blank" rel="noopener">获取公众号用户信息地址</a></p><p><a href="https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=%25s&amp;secret=%25s" target="_blank" rel="noopener">获取AccessToken的地址信息</a></p></blockquote><ol><li><p>配置回调信息方法</p><ol><li><p>编写一个Controller</p><pre class=" language-language-java"><code class="language-language-java">@PostMapping(value = "/gzh/callback", produces = "text/html;charset=UTF-8")public void callback(HttpServletRequest request, HttpServletResponse response) {  // 1.接受微信回调返回的信息，request 中  // 2.解析 request 中的数据，保存用户信息  // 3.响应对应的信息给微信  }</code></pre><p>微信服务号响应的信息</p><pre class=" language-language-xml"><code class="language-language-xml"><xml>  <!--公众号开发者id--><tousername><!--[CDATA[gh_533f0271744d]]--></tousername>  <!--openId--><fromusername><!--[CDATA[ouNui1FdfYOpzIYupSnE4-Q4jnoc]]--></fromusername><createtime>1578023225</createtime><msgtype><!--[CDATA[event]]--></msgtype><event><!--[CDATA[TEMPLATESENDJOBFINISH]]--></event><msgid>1148080904028422144</msgid><status><!--[CDATA[success]]--></status></xml></code></pre></li><li><p>公众号二维码带参数开发</p><p>公众号回调中的参数为：EventKey（自定义参数信息）</p></li><li><p>关注公众号回复多条信息</p><ol><li>被动回复消息（格式需要 XML）</li><li>主动发送消息：直接调用接口发送信息（格式需要 JSON）</li></ol></li></ol></li></ol><ol start="2"><li><h3><span id="小程序授权开发">小程序授权开发</span></h3></li></ol><blockquote><p>$\underline{需要的数据:}$</p><p>小程序的appId、appSecret 用于获取 AccessToken</p><p><a href="https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=%25s&amp;secret=%25s" target="_blank" rel="noopener">获取AccessToken的地址</a></p><p><a href="https://api.weixin.qq.com/sns/jscode2session?appid=APPID&amp;secret=SECRET&amp;js_code=JSCODE&amp;grant_type=authorization_code" target="_blank" rel="noopener">登录凭证校验地址(获取session_key)</a></p><p><a href="https://api.weixin.qq.com/cgi-bin/message/custom/send?access_token=ACCESS_TOKEN" target="_blank" rel="noopener">发送消息客服消息地址</a></p><p><a href="https://api.weixin.qq.com/cgi-bin/media/upload?access_token=%25s&amp;type=image" target="_blank" rel="noopener">上传素材地址</a></p></blockquote><ol><li><p>获取用户信息**（需要前端将相关的用户信息返回给我后端接口）**</p><p>传入的参数：</p><pre class=" language-language-properties"><code class="language-language-properties">avatarUrl: "https://wx.qlogo.cn/mmopen/vi_32/dpzd3qFvabQ2HRcQWloFHyyWSZTUKcUQfbwkJvYfp2icS0IBGFj0W0Bxv3JmfDrMgbnDVwfiaemDkOq70G2BKS4A/132"city: "Hangzhou"# code 用于调用接口获取 session_keycode: "033rAYt21RzvLQ1Yhdv21xqIt21rAYtm"country: "China"device: "iPhone 6/7/8 Plus"encryptData: "8TT5cvhq2OU62V4/yZE39QBLRqN8JtK03zWl1bKmqt0OMYxMWkzKX9DhcnS5RTWK0EPNH19s1EbaIH8nvO5kCQAPiBAoPUJFvcr7eIZGFv04iNFpZ7syBB7YS2M079rwmUTLM+HZB6eQmCDfDGJgTMOqmPHapu8UW2Xm1Qyf246QqzG6UZfdYx9GseXtDCzymOSfDW6UJiAKdxGdcQzSI2NRsQ1P2eDParY4loy3dGqRRSZLNJbULjIZV8sl855B/ZNaIid42JsdKIQyy9H6a1LlnNyJtQein+pIuGhhaCZscsdk9gUuyHhCufv0QHP87bmLDb+DxbeGIrVrGvQbuC3oN47NQo1wtaFhT5S/8zrl5hH578tWZSoflG+GmUppaaOqjQHtKKfsWv68+5fe5id3wgOf2gOUFyVqxD6UXiCaUtXRhAjXHnbBttL+e97CoHbUayPCC2x7oYjUcyVlKjF1Lwq85yDnyyB9VGO9Z01itgkz6hoU6A0vB3Adfuz0votTopvP0qGeaeaipSynWg=="gender: 2iv: "0tWYuyZ/MmyUHRKTutZhDA=="nickName: "BROKEN"province: "Zhejiang"type: 1000</code></pre><blockquote><p>iv + session_key + 算法能解密：encryptData 中的数据（unionId 等）</p></blockquote><p>算法：</p><pre class=" language-language-java"><code class="language-language-java">public class AESUtils {      private String sessionKey;    private String encryptedData;    private String iv;  public AESUtils(String sessionKey, String encryptedData, String iv) {        this.sessionKey = sessionKey;        this.encryptedData = encryptedData;        this.iv = iv;    }    // 解密方法    public String decrypt() throws Exception {        byte[] sessionKeyByte = Base64.decode(sessionKey);        byte[] encryptedDataByte = Base64.decode(encryptedData);        byte[] ivByte = Base64.decode(iv);        initialize();        Cipher cipher = Cipher.getInstance("AES/CBC/PKCS7Padding");        Key sKeySpec = new SecretKeySpec(sessionKeyByte, "AES");        cipher.init(Cipher.DECRYPT_MODE, sKeySpec, generateIV(ivByte));        //可以根据appid来判断是不是正确的结果        return new String(cipher.doFinal(encryptedDataByte));    }}</code></pre></li><li><p>授权手机号（参数由前端传入）</p><blockquote><p>iv + session_key + 算法能解密：encryptData 中的数据（ phoneNumber ）同上 1.</p></blockquote><p>encryptData 解密后的数据为：</p><pre class=" language-language-json"><code class="language-language-json">{    "phoneNumber": "13580006666",    "purePhoneNumber": "13580006666",    "countryCode": "86",    "watermark":    {        "appid":"APPID",        "timestamp": TIMESTAMP    }}</code></pre></li><li><p>小程序客服消息</p><ol><li><p>配置回调</p><pre class=" language-language-java"><code class="language-language-java">@GetMapping(value = "/xcx/msg/callback")public void wechatService(PrintWriter out,           HttpServletResponse response,          @RequestParam(value = "signature", required = false) String signature,          @RequestParam String timestamp,          @RequestParam String nonce,          @RequestParam String echostr) {        logger.error("回复微信消息成功：微信返回的信息：signature:{},timestamp:{},nonce:{},echostr:{}",signature, timestamp, nonce, echostr);  //原模原样将 echostr 字段返回        out.print(echostr);}</code></pre></li><li><p>微信小程序后台配置</p><p><img src="https://img.nbjike.com/jietu/20200103220314.png" alt="配置图"></p></li><li><p>处理小程序回调信息</p><pre class=" language-language-java"><code class="language-language-java">@PostMapping(value = "/xcx/msg/callback", produces = "text/html;charset=UTF-8")public void xcxMessageCallback(HttpServletRequest request, HttpServletResponse response){  // 1.接受微信小程序回调返回的信息，request 中  // 2.解析 request 中的数据，处理相关业务逻辑  //   处理小程序客服消息，回复图片等  // 3.响应对应的信息给微信  }</code></pre></li></ol></li><li><p>客服消息中回复用户图片（公众号回复多条消息也可以，accesstoken 换成公众号的）</p><ol><li><p>当客服消息中接收到用户消息是指定的内容时，回复对应的消息</p></li><li><p>将对应的消息封装成固定的消息模板（<a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/customer-message/customerServiceMessage.send.html" target="_blank" rel="noopener">参考小程序客服消息模板</a>）</p></li><li><p>将封装好的模板消息，post 发送</p><pre class=" language-language-java"><code class="language-language-java">/** *  message 封装好的消息模板 */private void sendMessage(String message) {String accessToken = "对应的accessToken"String url = "https://api.weixin.qq.com/cgi-bin/message/custom/send?access_token=" + accessToken;      try {            logger.info("发送客服消息为：{}", message);            httpClientInstance.post(url, message);       } catch (Exception e) {            logger.error("发送客服消息失败，msg:{}", e.getMessage(), e);       }}</code></pre><p>进入小程序客服消息回调返回信息：</p><pre class=" language-language-json"><code class="language-language-json">{    "ToUserName": "gh_15ac53a8de4b",    "FromUserName": "o7UjF5N_0mWTa3ydAX3A9uB-drEE",    "CreateTime": 1573648702,    "MsgType": "event",    "Event": "user_enter_tempsession",    "SessionFrom": "wxapp"}</code></pre><p>客服消息中发送微信小程序回调返回的信息：</p><pre class=" language-language-json"><code class="language-language-json">{    "ToUserName": "gh_15ac53a8de4b",    "FromUserName": "o7UjF5E50p5Voyl-zLjtmbE_HLKY",    "CreateTime": 1573648780,    "MsgType": "miniprogrampage",    "MsgId": 22529232614406832,    "Title": "小程序名称",    "AppId": "wx1cc77f731857276c",    "PagePath": "pages/order/order",    "ThumbUrl": "http://mmbiz.qpic.cn/mmbiz_jpg/yVGZpicgicib4l130z0DDDD7uSLl0z2iaicEvZxKAic2UlBXllItyvd5Eibibfp0COY54QtRT3vNdibkeHiaNY5cHbibSzOibQ/0",    "ThumbMediaId": "S64I_hy21v5NqgQ7H_5tFrOlMg9KwvxkLPfYHOsvYRvjivqi7OCFLFWw1KoBGth6"</code></pre></li></ol></li><li><p>客服消息中的图片如何获取（上传到微信服务器保存，微信返回 media_id，<strong>需要定期上传有效期 7 天</strong>）</p><p>上传代码：</p><pre class=" language-language-java"><code class="language-language-java">//上传的部分代码String accessToken = "获取的accessToken"        String reqUrl = String.format(url, accessToken);        String filePath = "img/gzh.jpg";        String data = OkHttpUtils.uploadImage(reqUrl, filePath);        JSONObject dataJSON = JSON.parseObject(data);        if (Objects.nonNull(dataJSON)) {            String mediaId = dataJSON.getString("media_id");            if (StringUtils.isNotBlank(mediaId)) {                redisCache.set("duancm_gzh_image", mediaId, 6 * 86400);                logger.info("临时图片设置成功");            }        }//上传核心代码，将 media_id 存入缓存中public static String uploadImage(String url, String imagePath) {        InputStream resourceAsStream = OkHttpUtils.class.getClassLoader().getResourceAsStream(imagePath);        File file = null;        try {            file = File.createTempFile("gzh", ".jpg");            if (Objects.nonNull(resourceAsStream)) {                FileUtils.copyInputStreamToFile(resourceAsStream, file);            }        } catch (IOException e) {            logger.error("获取文件失败,msg:{}", e.getMessage(), e);        }        if (Objects.isNull(file)) {            logger.error("获取文件为空");            return "";        }        RequestBody image = RequestBody.create(MediaType.parse("image/jpeg"), file);        RequestBody requestBody = new MultipartBody.Builder()                .setType(MultipartBody.FORM)                .addFormDataPart("file", imagePath, image)                .build();        Request request = new Request.Builder()                .url(url)                .post(requestBody)                .build();        try (Response response = commonRequest.newCall(request).execute()) {            if (response.isSuccessful() && response.body() != null) {                return Objects.requireNonNull(response.body()).string();            }        } catch (IOException e) {            logger.error("OkHttpUtils 上传图片失败，url：{}，msg：{}", url, e.getMessage(), e);        }        return "";    }</code></pre><p>上传图片素材 curl 命令：</p><pre class=" language-language-sh"><code class="language-language-sh">curl -F media=@图片文件名.jpg "https://api.weixin.qq.com/cgi-bin/media/upload?access_token=获取的access_token&type=image"</code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 小程序公众号 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Liunx 相关命令操作</title>
      <link href="/article/liunx-xiang-guan-ming-ling-cao-zuo/"/>
      <url>/article/liunx-xiang-guan-ming-ling-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h1><span id="liunx-相关命令操作">Liunx 相关命令操作</span></h1><pre class=" language-language-shell"><code class="language-language-shell"># 查看 liunx 中哪个目录日志多 ===》 https://linux.cn/article-9495-1.htmldu -s /* | sort -nr#方法1find / -type f -print0 | xargs -0 du -h | sort -rh | head -n 10#方法2find / -type f -exec du -Sh {} + | sort -rh | head -n 10#方法3 find / -type f -print0 | xargs -0 du | sort -n | tail -10 | cut -f2 | xargs -I{} du -sh {}#方法4find / -type f -ls | sort -k 7 -r -n | head -10 | column -t | awk '{print $7,$11}'# 查看 liunx 整个磁盘使用情况df -h# 查看 liunx 具体某个目录磁盘使用情况du -h /xxx# 对一个脚本配置别名echo "alias 别名=/usr/local/script/脚本.sh" >> ~/.bash_profilesource ~/.bash_profile# 查看 liunx 端口号netstat -ntulp#linux系统下单进程的线程数是有上线的，查看命令为ulimit -ulsof |grep deleted</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Liunx 相关命令操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis-log-helper 设置</title>
      <link href="/article/mybatis-log-helper-she-zhi/"/>
      <url>/article/mybatis-log-helper-she-zhi/</url>
      
        <content type="html"><![CDATA[<h1><span id="mybatis-log-helper-设置">Mybatis-log-helper 设置</span></h1><blockquote><p>Springboot 整合 Logback Mybatis-log-helper 不生效</p></blockquote><p>最简单的设置，直接在配置文件中设置</p><pre class=" language-language-properties"><code class="language-language-properties">mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl</code></pre><p>等价于：</p><p>配置文件配置</p><pre class=" language-language-xml"><code class="language-language-xml"><?xml version="1.0" encoding="UTF-8" ?><!DOCTYPE configuration        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"        "http://mybatis.org/dtd/mybatis-3-config.dtd"><configuration>    <settings>        <setting name="logImpl" value="STDOUT_LOGGING">    </setting></settings></configuration></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot 重定向</title>
      <link href="/article/springboot-chong-ding-xiang/"/>
      <url>/article/springboot-chong-ding-xiang/</url>
      
        <content type="html"><![CDATA[<h1><span id="springboot-重定向短链">Springboot 重定向短链</span></h1><ol><li><p>编写一个Controller</p><pre class=" language-language-java"><code class="language-language-java">@Controllerpublic class HiController {    @GetMapping("/hello")    @ResponseBody    public String hello() {        return "hello"; // 直接在页面上返回 hello    }    @GetMapping("/hi")    public String hi() {        return "redirect:https://dwz.cn/ymOMHebr"; //直接跳转至短链指定的位置    }}</code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> springboot 重定向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 基础</title>
      <link href="/article/mysql-count-yong-fa/"/>
      <url>/article/mysql-count-yong-fa/</url>
      
        <content type="html"><![CDATA[<h1><span id="mysql-基础">Mysql 基础</span></h1><ol><li>Mysql count 用法</li></ol><blockquote><p>1、COUNT有几种用法？</p><p>2、COUNT(字段名)和COUNT(*)的查询结果有什么不同？</p><p>3、COUNT(1)和COUNT(*)之间有什么不同？</p><p>4、COUNT(1)和COUNT(*)之间的效率哪个更高？</p><p>5、为什么《阿里巴巴Java开发手册》建议使用COUNT(*)</p><p>6、MySQL的MyISAM引擎对COUNT(*)做了哪些优化？</p><p>7、MySQL的InnoDB引擎对COUNT(*)做了哪些优化？</p><p>8、上面提到的MySQL对COUNT(*)做的优化，有一个关键的前提是什么？</p><p>9、SELECT COUNT(*) 的时候，加不加where条件有差别吗？</p><p>10、COUNT(*)、COUNT(1)和COUNT(字段名)的执行过程是怎样的？</p></blockquote><ol start="2"><li><p>Mysql 客户端执行SQL文件</p><pre class=" language-language-shell"><code class="language-language-shell">#客户端中source /文件路径/xx.sql</code></pre></li><li><p>查询两个表之间相同的数据和不同的数据</p><pre class=" language-language-sql"><code class="language-language-sql"># 不相同的数据select  *  from  newgoodscategory  A  where  A.id  NOT IN (select  B.ID  from tb_category  B );# 相同的数据数量select count(*)  from  newgoodscategory  A  where  A.id IN (select  B.ID  from tb_category  B );# 方式2select  *  from  tb_a   A  where  NOT EXISTS (select 1 from tb_b  B  where  A.ID = B.ID);</code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis 打印sql执行时间插件</title>
      <link href="/article/mybatis-da-yin-sql-zhi-xing-shi-jian-cha-jian/"/>
      <url>/article/mybatis-da-yin-sql-zhi-xing-shi-jian-cha-jian/</url>
      
        <content type="html"><![CDATA[<h1><span id="mybatis-打印sql执行时间插件">Mybatis 打印sql执行时间插件</span></h1><blockquote><p>起因：领导没有配置 mysql 慢 sql，让 diaosi 的我自己想办法。我 mlgb = make life getting better</p><p>mysql 没有配置慢 sql ，如何查看 sql 执行时间？想了许久后，能不能在 sql 开始执行的时候记录一次时间， sql执行结束时记录一次时间，将两次时间相减就是 sql 执行的时间。</p><p>现在的问题只要解决找到 sql 执行的方法，在那记录时间就 OK 了。那么如何找到 sql 执行的方法？mybatis 插件就给我们提供了很好的扩展。</p></blockquote><ol><li><p>编写 mybatis-sql 拦截插件：</p><pre class=" language-language-java"><code class="language-language-java">//日志记录@Slf4j@Configuration//需要拦截的方法@Intercepts({        @Signature(type = StatementHandler.class, method = "query", args = {Statement.class, ResultHandler.class}),        @Signature(type = StatementHandler.class, method = "update", args = {Statement.class}),        @Signature(type = StatementHandler.class, method = "batch", args = {Statement.class})})public class SqlCostInterceptor implements Interceptor {    @Override    public Object intercept(Invocation invocation) throws Throwable {      // 以下逻辑是找到对应的 mapper 方法        long startTime = System.currentTimeMillis();        try {            return invocation.proceed();        } finally {            long endTime = System.currentTimeMillis();            long costTime = endTime - startTime;            try {                Object target = invocation.getTarget();                if (target instanceof RoutingStatementHandler) {                    Field delegate = ReflectionUtils.findField(RoutingStatementHandler.class, "delegate");                    if (Objects.nonNull(delegate)) {                        delegate.setAccessible(true);                        Object object = delegate.get(target);                        if (object instanceof BaseStatementHandler) {                            Field field = ReflectionUtils.findField(BaseStatementHandler.class, "mappedStatement");                            if (Objects.nonNull(field)) {                                field.setAccessible(true);                                Object data = field.get(object);                                MappedStatement mappedStatement = (MappedStatement) data;                                String id = mappedStatement.getId();                                log.info(id + "：执行耗时：{} ms", costTime);                            }                        }                    }                }            } catch (Exception e) {                log.error("打印 sql 执行时间错误，msg：{}", e.getMessage(), e);            }        }    }    @Override    public Object plugin(Object target) {        return Plugin.wrap(target, this);    }    @Override    public void setProperties(Properties properties) {    }}</code></pre></li><li><p>配置 mybatis 插件（给 SqlSessionFactoryBean 对象设置刚刚编写好的插件）</p><pre class=" language-language-java"><code class="language-language-java">final SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean();        sessionFactory.setDataSource(rdsdataSource);        sessionFactory.setMapperLocations(                new PathMatchingResourcePatternResolver().getResources(mapperLocation));        sessionFactory.setConfigLocation(new ClassPathResource(configLocation));        sessionFactory.setPlugins(new Interceptor[]{new SqlCostInterceptor()});</code></pre></li><li><p>收集刚刚打印的日志信息（收集指定包下面的日志信息）</p><pre class=" language-language-xml"><code class="language-language-xml">    <!--sql-log-->    <appender name="BIGMOUSE-SQL-LOGGER" class="ch.qos.logback.core.rolling.RollingFileAppender">        <append>true</append>        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">            <level>${logging.level}</level>        </filter>        <file>            ${logging.path}/sql/sql.log        </file>        <rollingpolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">            <filenamepattern>${logging.path}/sql/sql.log.%d{yyyy-MM-dd}</filenamepattern>            <maxhistory>7</maxhistory>        </rollingpolicy>        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level - %msg%n</pattern>            <charset>UTF-8</charset>        </encoder>    </appender>   <logger name="刚刚插件的全限定类名" level="${logging.level}" additivity="false">        <appender-ref ref="BIGMOUSE-SQL-LOGGER">    </appender-ref></logger></code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Mybatis插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx 配置跨域</title>
      <link href="/article/nginx-pei-zhi-kua-yu/"/>
      <url>/article/nginx-pei-zhi-kua-yu/</url>
      
        <content type="html"><![CDATA[<h1><span id="nginx-配置跨域">Nginx 配置跨域</span></h1><blockquote><p>跨域是什么？</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx 一个域名配置不同location</title>
      <link href="/article/nginx-yi-ge-yu-ming-pei-zhi-bu-tong-location/"/>
      <url>/article/nginx-yi-ge-yu-ming-pei-zhi-bu-tong-location/</url>
      
        <content type="html"><![CDATA[<h1><span id="nginx-一个域名配置多个静态资源路径">Nginx 一个域名配置多个静态资源路径</span></h1><p>域名：<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p><p>当我想访问：<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 时指向服务器中的 /usr/local</p><p>当我想访问：<a href="http://www.baidu.com/hello" target="_blank" rel="noopener">www.baidu.com/hello</a> 时也指向服务器中的 /usr/local</p><p>location 配置</p><pre class=" language-language-shell"><code class="language-language-shell">location / {root /usr/local index  index.html index.htm;}location /hello {alias /usr/local/ index  index.html index.htm;}</code></pre><p>root 和 alias 区别</p><p>当配置为 root 时，访问 location 后的路径（xx）时会将实际路径变成：路径+xx</p><p>当配置为 alias 时，访问 location 后的路径（xx）时会将实际路径变成：路径</p>]]></content>
      
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx proxy_pass细节</title>
      <link href="/article/nginx-proxy-pass-xi-jie/"/>
      <url>/article/nginx-proxy-pass-xi-jie/</url>
      
        <content type="html"><![CDATA[<h1><span id="nginx-proxy_pass细节">Nginx proxy_pass细节</span></h1><p><strong>server_name</strong>  <a href="http://www.wzzzzzz.com">www.wzzzzzz.com</a></p><p><strong>proxy_pass</strong></p><p>​既是把请求代理到其他主机，其中 localhost:8080/ 写法和 localhost:8080写法的区别如下:</p><p><strong>不带/</strong></p><pre class=" language-language-sh"><code class="language-language-sh">`location /html/``{``　　proxy_pass http:``//b.com:8300; ``}`</code></pre><p><strong>带/</strong></p><pre class=" language-language-sh"><code class="language-language-sh">`location /html/ ``{ ``  ``proxy_pass http:``//b.com:8300/; ``}`</code></pre><p>上面两种配置，区别只在于 proxy_pass 转发的路径后是否带 “/”。</p><p>针对情况1，如果访问url = <a href="http://www.wzzzzzz.com/html%EF%BC%8C%E5%88%99%E8%A2%ABnginx%E4%BB%A3%E7%90%86%E5%90%8E%EF%BC%8C%E8%AF%B7%E6%B1%82%E8%B7%AF%E5%BE%84%E4%BC%9A%E4%BE%BF%E9%97%AE">http://www.wzzzzzz.com/html，则被nginx代理后，请求路径会便问</a> <a href="http://localhost:8080/html%EF%BC%8C%E5%B0%86/html/" target="_blank" rel="noopener">http://localhost:8080/html，将/html/</a> 作为根路径，请求/html/路径下的资源。</p><p>针对情况2，如果访问url =  <a href="http://www.wzzzzzz.com/html%EF%BC%8C%E5%88%99%E8%A2%ABnginx%E4%BB%A3%E7%90%86%E5%90%8E%EF%BC%8C%E8%AF%B7%E6%B1%82%E8%B7%AF%E5%BE%84%E4%BC%9A%E5%8F%98%E4%B8%BA">http://www.wzzzzzz.com/html，则被nginx代理后，请求路径会变为</a> <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a>，直接访问server的根资源。</p><p>简单的可以这样理解：</p><p>​不带 / <strong>会</strong>将 location 后的路径拼接到代理地址的后面</p><p>​带    /  <strong>不会</strong>将 location 后的路径拼接到代理地址的后面</p><blockquote><p><a href="https://my.oschina.net/foreverich/blog/1512304" target="_blank" rel="noopener">https://my.oschina.net/foreverich/blog/1512304</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux安装 node 环境</title>
      <link href="/article/linux-an-zhuang-node-huan-jing/"/>
      <url>/article/linux-an-zhuang-node-huan-jing/</url>
      
        <content type="html"><![CDATA[<h1><span id="linux安装-node-环境">Linux安装 node 环境</span></h1><ol><li><p><a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">官网下载</a></p><pre class=" language-language-shell"><code class="language-language-shell">wget -c https://nodejs.org/dist/v10.16.3/node-v10.16.3-linux-x64.tar.xz</code></pre></li><li><p>解压</p><pre class=" language-language-sh"><code class="language-language-sh">tar -xvf node-v10.16.3-linux-x64.tar.xz</code></pre></li><li><p>建立软链接</p><pre class=" language-language-sh"><code class="language-language-sh">sudo ln -s 安装目录/bin/node /usr/local/bin/node`sudo ln -s 安装目录/bin/npm /usr/local/bin/npm</code></pre></li><li><p>安装cnpm</p><pre class=" language-language-shell"><code class="language-language-shell">npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre></li></ol><blockquote><p><a href="https://segmentfault.com/a/1190000012297511" target="_blank" rel="noopener">参考</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node 和 npm 的区别</title>
      <link href="/article/node-he-npm-de-qu-bie/"/>
      <url>/article/node-he-npm-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<h1><span id="node-和-npm-的区别">Node 和 Npm 的区别</span></h1><p><strong>Node:</strong></p><p>​js 代码运行环境（node.js是javascript的一种运行环境，是一个服务器端的javascript的解释器。）</p><p><strong>npm：</strong></p><p>​node package manage ，(node 的包管理工具) 可以安装别人已经开发好的 js 代码</p>]]></content>
      
      
      
        <tags>
            
            <tag> Node </tag>
            
            <tag> Npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用构建器代替多个构造器参数</title>
      <link href="/article/shi-yong-gou-jian-qi-dai-ti-duo-ge-gou-zao-qi-can-shu/"/>
      <url>/article/shi-yong-gou-jian-qi-dai-ti-duo-ge-gou-zao-qi-can-shu/</url>
      
        <content type="html"><![CDATA[<h1><span id="使用构建器代替多个构造器参数">使用构建器代替多个构造器参数</span></h1><ol><li>实例代码</li></ol><pre class=" language-language-java"><code class="language-language-java">public class Student {  //全局变量，有静态内部类的方法赋值    private final String  name;    private final Integer age;    private final String  phone;    public static class Builder {        private String  name;        private Integer age;        private String  phone;      //给外部类赋值的方法        public Builder name(String val) {            name = val;            return this;        }        public Builder age(Integer val) {            age = val;            return this;        }        public Builder phone(String val) {            phone = val;            return this;        }      //静态内部类的构造器，用于创建外部类的对象        public Student build() {          //调用外面类的私有构造器            return new Student(this);        }    }  //外部类的私有构造器    private Student(Builder builder) {        name = builder.name;        age = builder.age;        phone = builder.phone;    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos7 上安装Nginx —— 压缩包的方式</title>
      <link href="/article/centos7-shang-an-zhuang-nginx/"/>
      <url>/article/centos7-shang-an-zhuang-nginx/</url>
      
        <content type="html"><![CDATA[<h1><span id="centos7-上安装nginx-压缩包的方式">Centos7 上安装Nginx —— 压缩包的方式</span></h1><ol><li><p>打开官网</p><blockquote><p><a href="https://nginx.org/en/" target="_blank" rel="noopener">https://nginx.org/en/</a> 不收费的以 .org 的结尾</p></blockquote></li><li><p>找到对应的版本</p></li><li><p>使用下载命令</p><pre class=" language-language-sh"><code class="language-language-sh">wget https://nginx.org/download/nginx-1.14.2.tar.gz</code></pre></li><li><p>使用解压命令</p><pre class=" language-language-sh"><code class="language-language-sh"> tar -zxvf nginx-1.14.2.tar.gz</code></pre></li><li><p>安装gcc （c 环境）</p><pre class=" language-language-sh"><code class="language-language-sh">yum install -y gcc-c++</code></pre></li><li><p>PCRE pcre-devel 安装</p><pre class=" language-language-sh"><code class="language-language-sh">yum install -y pcre pcre-devel</code></pre></li><li><p>zlib 安装</p><pre class=" language-language-sh"><code class="language-language-sh">yum install -y zlib zlib-devel</code></pre></li><li><p>OpenSSL 安装</p><pre class=" language-language-sh"><code class="language-language-sh">yum install -y openssl openssl-devel</code></pre></li><li><p>进入解压目录</p><pre class=" language-language-sh"><code class="language-language-sh">./configure --prefix=[自己指定的安装目录] && make install</code></pre></li><li><p>配置环境变量</p><pre class=" language-language-sh"><code class="language-language-sh">echo 'export PATH=$PATH:home/software/install_package/nginx_ins/sbin' > /etc/profile.d/nginx.sh</code></pre></li><li><p>环境变量生效</p><pre class=" language-language-sh"><code class="language-language-sh">source /etc/profile</code></pre></li><li><p>查看是否生效</p><pre class=" language-language-sh"><code class="language-language-sh">whereis nginx</code></pre></li></ol><p>启动Nginx</p><pre class=" language-language-sh"><code class="language-language-sh">nginx</code></pre><p>输入自己的主机IP地址，出现</p><p><img src="https://img.nbjike.com/jietu/20190728190116.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>换了电脑如何写 Hexo 博客</title>
      <link href="/article/bo-ke-huan-liao-dian-nao-ru-he-xie-hexo-bo-ke/"/>
      <url>/article/bo-ke-huan-liao-dian-nao-ru-he-xie-hexo-bo-ke/</url>
      
        <content type="html"><![CDATA[<h1><span id="换了电脑如何写-hexo-博客">换了电脑如何写 Hexo 博客？</span></h1><ol><li><p>拷贝文件目录</p><blockquote><p>_config.yml<br>package.json<br>scaffolds/<br>source/<br>themes/</p></blockquote></li><li><p>在你的新电脑上首先配置hexo环境：安装Node.js</p></li><li><p>安装hexo，执行命令：</p><pre class=" language-language-sh"><code class="language-language-sh">npm install -g hexo</code></pre></li><li><p>安装好之后，进入hexo／目录</p></li><li><p>模块安装，执行命令：</p><pre class=" language-language-sh"><code class="language-language-sh">npm installnpm install hexo-deployer-git --savenpm install hexo-generator-feed --savenpm install hexo-generator-sitemap --save</code></pre></li><li><p>部署，执行命令</p><pre class=" language-language-sh"><code class="language-language-sh">hexo ghexo deploy</code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac 相关操作</title>
      <link href="/article/mac-xiang-guan-cao-zuo/"/>
      <url>/article/mac-xiang-guan-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h1><span id="mac-相关操作">mac 相关操作</span></h1><h3><span id="1如何从liunx上下载软件到mac上">1.如何从liunx上下载软件到mac上</span></h3><pre class=" language-language-shell"><code class="language-language-shell">使用shell命令tiaozao@192.168.1.1    ->  liunx用户名@liunx服务器地址/data/wwwroot/default/111.png -> 服务器上的文件路径/Users/mac_pc/Desktop -> 本地mac上的路径scp tiaozao@192.168.1.1:/data/tiaozao/default/111.png /Users/mac_pc/Desktop传输文件夹sup -r root@192.168.1.1:/data/wwwroot/default/test /Users/mac_pc/Desktop</code></pre><h3><span id="2mac-中如何在终端打开对应的文件夹目录">2.mac 中如何在终端打开对应的文件夹目录</span></h3><pre class=" language-language-shell"><code class="language-language-shell">在终端的某个目录下使用open .</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos7 安装 git 压缩包</title>
      <link href="/article/centos7-an-zhuang-git-ya-suo-bao/"/>
      <url>/article/centos7-an-zhuang-git-ya-suo-bao/</url>
      
        <content type="html"><![CDATA[<h1><span id="centos7-安装-git-压缩包">Centos7 安装 git 压缩包</span></h1><h3><span id="1下载-git-压缩包并解压">1.下载 git 压缩包并解压</span></h3><blockquote><p>git 相关资源</p><p><a href="https://mirrors.edge.kernel.org/pub/software/scm/git/" target="_blank" rel="noopener">https://mirrors.edge.kernel.org/pub/software/scm/git/</a></p></blockquote><p>使用命令下载压缩包：</p><pre class=" language-language-shell"><code class="language-language-shell">wget https://www.kernel.org/pub/software/scm/git/git-2.7.3.tar.gz</code></pre><p>使用命令解压压缩包：</p><pre class=" language-language-shell"><code class="language-language-shell">tar -zxvf git-2.7.3.tar.gz</code></pre><p>进入解压后的目录</p><pre class=" language-language-shell"><code class="language-language-shell">cd git-2.7.3</code></pre><h3><span id="2安装相关依赖">2.安装相关依赖</span></h3><pre class=" language-language-shell"><code class="language-language-shell">yum -y install gcc openssl openssl-devel curl curl-devel unzip perl perl-devel expat expat-devel zlib zlib-devel asciidoc xmlto gettext-devel openssh-clients</code></pre><h3><span id="3编译">3.编译</span></h3><pre class=" language-language-shell"><code class="language-language-shell">make /usr/local/software/git/install/ install</code></pre><blockquote><p>/usr/local/software/git/install/ ：为编译的目录；install：命令</p></blockquote><h3><span id="4配置全局命令">4.配置全局命令</span></h3><pre class=" language-language-shell"><code class="language-language-shell">export PATH="/usr/local/software/git/bin:$PATH"source /etc/profile</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 设计模式——七大原则</title>
      <link href="/article/java-she-ji-mo-shi-qi-da-yuan-ze/"/>
      <url>/article/java-she-ji-mo-shi-qi-da-yuan-ze/</url>
      
        <content type="html"><![CDATA[<h1><span id="java-设计模式七大原则">Java 设计模式——七大原则</span></h1><h3><span id="1单一职责原则">1.单一职责原则</span></h3><p>​例子：Mybatis 整合 Spring 各种 XXXMapper 只操作相应的数据库表</p><p>​class 类级别的单一原则</p><p>​不同的业务，不同的业务类</p><p>​method 方法级别的单一原则</p><p>​同一个类中，不同的业务方法（例如工具类，中不同的方法）</p><h3><span id="2接口隔离原则">2.接口隔离原则</span></h3><p>​客户端不应该依赖它不需要的接口，即一个类对对另外一个类的依赖应该建立在最小的接口上。</p><p>​例如：类A</p><h3><span id="3依赖倒转原则">3.依赖倒转原则</span></h3><h3><span id="4里式替换原则">4.里式替换原则</span></h3><h3><span id="5开闭原则">5.开闭原则</span></h3><h3><span id="6迪米特法则">6.迪米特法则</span></h3><h3><span id="7合成复用原则">7.合成复用原则</span></h3>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpingBoot 配置 Swagger2</title>
      <link href="/article/spingboot-pei-zhi-swagger2/"/>
      <url>/article/spingboot-pei-zhi-swagger2/</url>
      
        <content type="html"><![CDATA[<h1><span id="spingboot-配置-swagger2">SpingBoot 配置 Swagger2</span></h1><ul><li><p>先创建 Swagger 配置类，将 Swagger 交给 Spring ioc 管理</p><p><img src="C:%5CUsers%5Cz%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1557073286631.png" alt="1557073286631"></p></li><li></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置连接服务器的脚本</title>
      <link href="/article/pei-zhi-lian-jie-fu-wu-qi-de-jiao-ben/"/>
      <url>/article/pei-zhi-lian-jie-fu-wu-qi-de-jiao-ben/</url>
      
        <content type="html"><![CDATA[<h1><span id="配置连接服务器的脚本">配置连接服务器的脚本</span></h1><p>配置脚本：</p><pre class=" language-language-shell"><code class="language-language-shell">#!/usr/bin/expectset timeout 3spawn ssh root@IP地址expect "*password*"send "密码\r"interact</code></pre><p>配置脚本别名：</p><pre class=" language-language-she"><code class="language-language-she">echo "alias 别名=/脚本路径/xxx.sh" >> ~/.bash_profile</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title> Mysql 驱动版本错误</title>
      <link href="/article/mysql-qu-dong-ban-ben-cuo-wu/"/>
      <url>/article/mysql-qu-dong-ban-ben-cuo-wu/</url>
      
        <content type="html"><![CDATA[<h1><span id="mysql-驱动版本错误">Mysql 驱动版本错误</span></h1><p><strong>报错</strong>：</p><pre class=" language-language-java"><code class="language-language-java">com.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException: Could not create connection to database server.at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) ~[na:1.8.0_201]at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) ~[na:1.8.0_201]at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) ~[na:1.8.0_201]at java.lang.reflect.Constructor.newInstance(Constructor.java:423) ~[na:1.8.0_201]at com.mysql.jdbc.Util.handleNewInstance(Util.java:377) ~[mysql-connector-java-5.1.33.jar:5.1.33]at com.mysql.jdbc.Util.getInstance(Util.java:360) ~[mysql-connector-java-5.1.33.jar:5.1.33]at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:956) ~[mysql-connector-java-5.1.33.jar:5.1.33]at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:935) ~[mysql-connector-java-5.1.33.jar:5.1.33]at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:924) ~[mysql-connector-java-5.1.33.jar:5.1.33]at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:870) ~[mysql-connector-java-5.1.33.jar:5.1.33]at com.mysql.jdbc.ConnectionImpl.connectOneTryOnly(ConnectionImpl.java:2311) ~[mysql-connector-java-5.1.33.jar:5.1.33]at com.mysql.jdbc.ConnectionImpl.createNewIO(ConnectionImpl.java:2064) ~[mysql-connector-java-5.1.33.jar:5.1.33]at com.mysql.jdbc.ConnectionImpl.<init>(ConnectionImpl.java:790) ~[mysql-connector-java-5.1.33.jar:5.1.33]at com.mysql.jdbc.JDBC4Connection.<init>(JDBC4Connection.java:44) ~[mysql-connector-java-5.1.33.jar:5.1.33]at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) ~[na:1.8.0_201]at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) ~[na:1.8.0_201]at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) ~[na:1.8.0_201]at java.lang.reflect.Constructor.newInstance(Constructor.java:423) ~[na:1.8.0_201]at com.mysql.jdbc.Util.handleNewInstance(Util.java:377) ~[mysql-connector-java-5.1.33.jar:5.1.33]at com.mysql.jdbc.ConnectionImpl.getInstance(ConnectionImpl.java:395) ~[mysql-connector-java-5.1.33.jar:5.1.33]at com.mysql.jdbc.NonRegisteringDriver.connect(NonRegisteringDriver.java:325) ~[mysql-connector-java-5.1.33.jar:5.1.33]at com.zaxxer.hikari.util.DriverDataSource.getConnection(DriverDataSource.java:117) ~[HikariCP-2.7.8.jar:na]at com.zaxxer.hikari.util.DriverDataSource.getConnection(DriverDataSource.java:123) ~[HikariCP-2.7.8.jar:na]at com.zaxxer.hikari.pool.PoolBase.newConnection(PoolBase.java:365) ~[HikariCP-2.7.8.jar:na]at com.zaxxer.hikari.pool.PoolBase.newPoolEntry(PoolBase.java:194) ~[HikariCP-2.7.8.jar:na]at com.zaxxer.hikari.pool.HikariPool.createPoolEntry(HikariPool.java:460) [HikariCP-2.7.8.jar:na]at com.zaxxer.hikari.pool.HikariPool.checkFailFast(HikariPool.java:534) [HikariCP-2.7.8.jar:na]at com.zaxxer.hikari.pool.HikariPool.<init>(HikariPool.java:115) [HikariCP-2.7.8.jar:na]at com.zaxxer.hikari.HikariDataSource.getConnection(HikariDataSource.java:112) [HikariCP-2.7.8.jar:na]at org.springframework.jdbc.datasource.DataSourceUtils.fetchConnection(DataSourceUtils.java:151) [spring-jdbc-5.0.5.RELEASE.jar:5.0.5.RELEASE]at org.springframework.jdbc.datasource.DataSourceUtils.doGetConnection(DataSourceUtils.java:115) [spring-jdbc-5.0.5.RELEASE.jar:5.0.5.RELEASE]at org.springframework.jdbc.datasource.DataSourceUtils.getConnection(DataSourceUtils.java:78) [spring-jdbc-5.0.5.RELEASE.jar:5.0.5.RELEASE]at org.mybatis.spring.transaction.SpringManagedTransaction.openConnection(SpringManagedTransaction.java:82) [mybatis-spring-1.3.2.jar:1.3.2]at org.mybatis.spring.transaction.SpringManagedTransaction.getConnection(SpringManagedTransaction.java:68) [mybatis-spring-1.3.2.jar:1.3.2]at org.apache.ibatis.executor.BaseExecutor.getConnection(BaseExecutor.java:338) [mybatis-3.4.6.jar:3.4.6]at org.apache.ibatis.executor.SimpleExecutor.prepareStatement(SimpleExecutor.java:84) [mybatis-3.4.6.jar:3.4.6]at org.apache.ibatis.executor.SimpleExecutor.doQuery(SimpleExecutor.java:62) [mybatis-3.4.6.jar:3.4.6]at org.apache.ibatis.executor.BaseExecutor.queryFromDatabase(BaseExecutor.java:326) [mybatis-3.4.6.jar:3.4.6]at org.apache.ibatis.executor.BaseExecutor.query(BaseExecutor.java:156) [mybatis-3.4.6.jar:3.4.6]at org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:109) [mybatis-3.4.6.jar:3.4.6]at org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:83) [mybatis-3.4.6.jar:3.4.6]at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:148) [mybatis-3.4.6.jar:3.4.6]at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:141) [mybatis-3.4.6.jar:3.4.6]at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_201]at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_201]at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_201]at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_201]at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:433) [mybatis-spring-1.3.2.jar:1.3.2]at com.sun.proxy.$Proxy71.selectList(Unknown Source) [na:na]at org.mybatis.spring.SqlSessionTemplate.selectList(SqlSessionTemplate.java:230) [mybatis-spring-1.3.2.jar:1.3.2]at org.apache.ibatis.binding.MapperMethod.executeForMany(MapperMethod.java:139) [mybatis-3.4.6.jar:3.4.6]at org.apache.ibatis.binding.MapperMethod.execute(MapperMethod.java:76) [mybatis-3.4.6.jar:3.4.6]at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:59) [mybatis-3.4.6.jar:3.4.6]at com.sun.proxy.$Proxy72.selectByExample(Unknown Source) [na:na]at com.tiaozao.bigpig.douyin.dyuser.dao.impl.DyuserDaoImpl.queryDyuser(DyuserDaoImpl.java:21) [classes/:na]at com.tiaozao.bigpig.douyin.dyuser.DyuserMapperTest.queryDyuserTest(DyuserMapperTest.java:25) [test-classes/:na]at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_201]at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_201]at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_201]at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_201]at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) [junit-4.12.jar:4.12]at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) [junit-4.12.jar:4.12]at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) [junit-4.12.jar:4.12]at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) [junit-4.12.jar:4.12]at org.springframework.test.context.junit4.statements.RunBeforeTestExecutionCallbacks.evaluate(RunBeforeTestExecutionCallbacks.java:73) [spring-test-5.0.5.RELEASE.jar:5.0.5.RELEASE]at org.springframework.test.context.junit4.statements.RunAfterTestExecutionCallbacks.evaluate(RunAfterTestExecutionCallbacks.java:83) [spring-test-5.0.5.RELEASE.jar:5.0.5.RELEASE]at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:75) [spring-test-5.0.5.RELEASE.jar:5.0.5.RELEASE]at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:86) [spring-test-5.0.5.RELEASE.jar:5.0.5.RELEASE]at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:84) [spring-test-5.0.5.RELEASE.jar:5.0.5.RELEASE]at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) [junit-4.12.jar:4.12]at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:251) [spring-test-5.0.5.RELEASE.jar:5.0.5.RELEASE]at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:97) [spring-test-5.0.5.RELEASE.jar:5.0.5.RELEASE]at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) [junit-4.12.jar:4.12]at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) [junit-4.12.jar:4.12]at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) [junit-4.12.jar:4.12]at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) [junit-4.12.jar:4.12]at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) [junit-4.12.jar:4.12]at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61) [spring-test-5.0.5.RELEASE.jar:5.0.5.RELEASE]at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70) [spring-test-5.0.5.RELEASE.jar:5.0.5.RELEASE]at org.junit.runners.ParentRunner.run(ParentRunner.java:363) [junit-4.12.jar:4.12]at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:190) [spring-test-5.0.5.RELEASE.jar:5.0.5.RELEASE]at org.junit.runner.JUnitCore.run(JUnitCore.java:137) [junit-4.12.jar:4.12]at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) [junit-rt.jar:na]at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) [junit-rt.jar:na]at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) [junit-rt.jar:na]at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70) [junit-rt.jar:na]Caused by: java.lang.NullPointerException: nullat com.mysql.jdbc.ConnectionImpl.getServerCharset(ConnectionImpl.java:2983) ~[mysql-connector-java-5.1.33.jar:5.1.33]at com.mysql.jdbc.MysqlIO.sendConnectionAttributes(MysqlIO.java:1873) ~[mysql-connector-java-5.1.33.jar:5.1.33]at com.mysql.jdbc.MysqlIO.proceedHandshakeWithPluggableAuthentication(MysqlIO.java:1802) ~[mysql-connector-java-5.1.33.jar:5.1.33]at com.mysql.jdbc.MysqlIO.doHandshake(MysqlIO.java:1206) ~[mysql-connector-java-5.1.33.jar:5.1.33]at com.mysql.jdbc.ConnectionImpl.coreConnect(ConnectionImpl.java:2234) ~[mysql-connector-java-5.1.33.jar:5.1.33]at com.mysql.jdbc.ConnectionImpl.connectOneTryOnly(ConnectionImpl.java:2265) ~[mysql-connector-java-5.1.33.jar:5.1.33]... 75 common frames omitted</init></init></init></code></pre><p>原因：</p><blockquote><p>mysql 数据库是8.0+的版本，数据库驱动是5.0+，驱动不能创建连接</p></blockquote><p>解决：</p><blockquote><p>将mysql 连接版本改为8.0+</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spingboot 多模块单元测试</title>
      <link href="/article/spingboot-duo-mo-kuai-dan-yuan-ce-shi/"/>
      <url>/article/spingboot-duo-mo-kuai-dan-yuan-ce-shi/</url>
      
        <content type="html"><![CDATA[<h1><span id="spingboot-多模块单元测试">Spingboot 多模块单元测试</span></h1><h2><span id="dao-模块下的单元测试">Dao 模块下的单元测试：</span></h2><p><img src="https://img.nbjike.com/jietu/1556954255181.png" alt="1556954255181"></p><p>Tips：</p><ul><li>如果主启动类和测试类在同一个包下，则无需在 @SpringBootTest 的 classes = 无需指定</li><li>如果主启动类和测试类不在同一个包下，则需在 @SpringBootTest(classes = BigpigApplication.class) 指定主启动类</li></ul><p>如下图所示：</p><p><img src="https://img.nbjike.com/jietu/1556954782354.png" alt="1556954782354"></p>]]></content>
      
      
      
        <tags>
            
            <tag> spingboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title> 解决org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)问题</title>
      <link href="/article/jie-jue-org.apache.ibatis.binding.bindingexception-invalid-bound-statement-not-found-wen-ti/"/>
      <url>/article/jie-jue-org.apache.ibatis.binding.bindingexception-invalid-bound-statement-not-found-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1><span id="解决orgapacheibatisbindingbindingexception-invalid-bound-statement-not-found问题">解决org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)问题</span></h1><h2><span id="1出现该问题的原因一">1.出现该问题的原因一</span></h2><p>mapper.xml 中的命名空间与 mapper 接口未能对应上</p><p><img src="https://img-blog.csdn.net/20180813151254454?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1bmRhY2hlbmcxOTg5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><h2><span id="2必须配置mapperxml的位置">2.必须配置mapper.xml的位置</span></h2><p>不然相当于 mapper 接口找不到实现类</p>]]></content>
      
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title> Maven 多模块中子模块如何使用父模块的依赖</title>
      <link href="/article/maven-duo-mo-kuai-zhong-zi-mo-kuai-ru-he-shi-yong-fu-mo-kuai-de-yi-lai/"/>
      <url>/article/maven-duo-mo-kuai-zhong-zi-mo-kuai-ru-he-shi-yong-fu-mo-kuai-de-yi-lai/</url>
      
        <content type="html"><![CDATA[<h1><span id="maven-多模块中子模块如何使用父模块的依赖">Maven 多模块中子模块如何使用父模块的依赖</span></h1><ol><li><p>如果父模块使用的是：</p><pre class=" language-language-xml"><code class="language-language-xml"><dependency></dependency></code></pre><p><strong>则子模块自动拥有父模块对应的依赖（jar包）</strong></p></li><li><p>如果父模块使用的是：</p><pre class=" language-language-xml"><code class="language-language-xml"><dependencymanagement></dependencymanagement></code></pre><p>则子模块<strong>不会</strong>自动拥有父模块对应的依赖（jar包），若需要拥有对应的依赖，则需要在子模块中添加</p><pre class=" language-language-xml"><code class="language-language-xml"><groupid>xxx</groupid><artifactid>xxxxxx</artifactid></code></pre><p>无需添加对应的版本，因为版本已经交给父模块管理，若想与父模块使用不同的版本，则添加对应的版本</p><pre class=" language-language-xml"><code class="language-language-xml"><groupid>xxx</groupid><artifactid>xxxxxx</artifactid><version>1.6.1</version></code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Hexo] Theme tiaozao</title>
      <link href="/article/tiaozao-theme/"/>
      <url>/article/tiaozao-theme/</url>
      
        <content type="html"><![CDATA[<blockquote><p>This TIAOZAO theme created by <a href="http://www.wzzzzzz.com/">TiaoZao</a> modified from the original Porter <a href="https://github.com/YenYuHsuan/hexo-theme-beantech" target="_blank" rel="noopener">YuHsuan</a></p></blockquote><h1><span id="live-demo">Live Demo</span></h1><p>TiaoZao Blog : <a href="https://www.wzzzzzz.com/">www.wzzzzzz.com</a></p><p><img src="https://res.cloudinary.com/dqxtn0ick/image/upload/v1553666111/blog/blog.jpg" alt="Theme HuWeihuang"></p><h1><span id="install-hexo">Install Hexo</span></h1><p>Install Node.js  and Git</p><pre class=" language-language-shell"><code class="language-language-shell">#For Macbrew install nodebrew install git</code></pre><p>Install hexo</p><pre class=" language-language-shell"><code class="language-language-shell">npm install hexo-cli -g#For more:https://hexo.io/zh-cn/index.html</code></pre><h1><span id="theme-usage">Theme Usage</span></h1><h2><span id="init">Init</span></h2><hr><pre class=" language-language-bash"><code class="language-language-bash">git clone https://github.com/huweihuang/hexo-theme-huweihuang.git ./hexo-huweihuangcd hexo-huweihuangnpm install</code></pre><h2><span id="modify">Modify</span></h2><hr><p>Modify <code>_config.yml</code> file with your own info.<br>Especially the section:</p><h3><span id="deployment">Deployment</span></h3><p>Replace to your own repo!</p><pre class=" language-language-yml"><code class="language-language-yml">deploy:  type: git  repo: https://github.com/<youraccount>/<repo>  branch: <your-branch></your-branch></repo></youraccount></code></pre><h3><span id="sidebar-settings">Sidebar settings</span></h3><p>Copy your avatar image to <code>&lt;root&gt;/img/</code> and modify the <code>_config.yml</code>:</p><pre class=" language-language-yml"><code class="language-language-yml">sidebar: true    # whether or not using Sidebar.sidebar-about-description: "<your description>"sidebar-avatar: img/<your avatar path></your></your></code></pre><p>and activate your personal widget you like</p><pre class=" language-language-yml"><code class="language-language-yml">widgets:         # here are widget you can use, you can comment out- featured-tags- short-about- recent-posts- friends-blog- archive- category</code></pre><p>if you want to add sidebar widget, please add at <code>layout/_widget</code>.</p><h3><span id="signature-setup">Signature Setup</span></h3><p>Copy your signature image to <code>&lt;root&gt;/img/signature</code> and modify the <code>_config.yml</code>:</p><pre class=" language-language-yml"><code class="language-language-yml">signature: true   # show signaturesignature-img: img/signature/<your-signature-id></your-signature-id></code></pre><h3><span id="go-to-top-icon-setup">Go to top icon Setup</span></h3><p>My icon is using iron man, you can change to your own icon at <code>css/image</code>.</p><h3><span id="post-tag">Post tag</span></h3><p>You can decide to show post tags or not.</p><pre class=" language-language-yml"><code class="language-language-yml">home_posts_tag: true</code></pre><p><img src="/img/article/tag.png" alt="home_posts_tag-true"></p><h3><span id="markdown-render">Markdown render</span></h3><p>My markdown render engine plugin is <a href="https://github.com/celsomiranda/hexo-renderer-markdown-it" target="_blank" rel="noopener">hexo-renderer-markdown-it</a>.</p><pre class=" language-language-yml"><code class="language-language-yml"># Markdown-it config## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wikimarkdown:  render:    html: true    xhtmlOut: false    breaks: true    linkify: true    typographer: true    quotes: '“”‘’'</code></pre><p>and if you want to change the header anchor ‘ℬ’, you can go to <code>layout/post.ejs</code> to change it.</p><pre class=" language-language-javascript"><code class="language-language-javascript">async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){        anchors.options = {          visible: 'hover',          placement: 'left',          icon: ℬ // this is the header anchor "unicode" icon        };</code></pre><h2><span id="hexo-basics">Hexo Basics</span></h2><hr><p>Some hexo command:</p><pre class=" language-language-bash"><code class="language-language-bash">hexo new post "<post name>" # you can change post to another layout if you wanthexo clean && hexo generate # generate the static filehexo server # run hexo in local environmenthexo deploy # hexo will push the static files automatically into the specific branch(gh-pages) of your repo!</post></code></pre><h1><span id="have-fun-_">Have fun ^_^</span></h1><hr><!-- Place this tag in your head or just before your close body tag. --><script async defer src="https://buttons.github.io/buttons.js"></script><!-- Place this tag where you want the button to render. --><p>Please <a class="github-button" href="https://github.com/huweihuang/hexo-theme-huweihuang" data-icon="octicon-star" aria-label="Star huweihuang/hexo-theme-huweihuang on GitHub" target="_blank" rel="noopener">Star</a> this Project if you like it! <a class="github-button" href="https://github.com/huweihuang" aria-label="Follow @huweihuang on GitHub" target="_blank" rel="noopener">Follow</a> would also be appreciated!<br>Peace!</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql Explain执行计划</title>
      <link href="/article/mysql-explain-zhi-xing-ji-hua/"/>
      <url>/article/mysql-explain-zhi-xing-ji-hua/</url>
      
        <content type="html"><![CDATA[<h1><span id="mysql-explain执行计划">Mysql Explain执行计划</span></h1>]]></content>
      
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 回表</title>
      <link href="/article/mysql-hui-biao/"/>
      <url>/article/mysql-hui-biao/</url>
      
        <content type="html"><![CDATA[<h1><span id="mysql-回表">Mysql 回表</span></h1><blockquote><p><a href="https://www.cnblogs.com/myseries/p/11265849.html" target="_blank" rel="noopener">MySQL优化：如何避免回表查询？什么是索引覆盖？</a></p></blockquote><p><strong>什么是回表查询？</strong></p><p><img src="https://img.nbjike.com/jietu/20200523214121.png" alt></p><p><strong>什么是索引覆盖？</strong></p><p><img src="https://img.nbjike.com/jietu/20200523220128.png" alt></p><p><strong>如何实现索引覆盖？</strong></p><p>常见的方法是：将被查询的字段，建立到联合索引里去。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 内置函数</title>
      <link href="/article/mysql-nei-zhi-han-shu/"/>
      <url>/article/mysql-nei-zhi-han-shu/</url>
      
        <content type="html"><![CDATA[<h1><span id="mysql-内置函数">Mysql 内置函数</span></h1><pre class=" language-language-mysql"><code class="language-language-mysql"># 查看当前 mysql 有多少客户端连接show PROCESSLIST# 查看当前数据库所有表的状态show table statusSHOW TABLE STATUS    [{FROM | IN} db_name]    [LIKE 'pattern' | WHERE expr]#当表的平均长度不同时，平均长度短的查询快（相同数据量的情况下）</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 执行sql文件</title>
      <link href="/article/mysql-zhi-xing-sql-wen-jian/"/>
      <url>/article/mysql-zhi-xing-sql-wen-jian/</url>
      
        <content type="html"><![CDATA[<h1><span id="mysql-执行sql文件">Mysql 执行sql文件</span></h1><pre class=" language-language-sh"><code class="language-language-sh">#常用source 命令#进入mysql数据库控制台，如mysql -u root -pmysql>use 数据库名称#然后使用source命令，后面参数为脚本文件(如这里用到的.sql)mysql>source 路径加/dbname.sql</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
